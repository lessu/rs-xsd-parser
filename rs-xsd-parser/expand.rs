#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod xsd {
    pub mod annotation {
        use yaserde::*;
        /**
 * <annotation
 *  id = ID
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (appinfo | documentation)*
 * </annotation>
 */
        #[yaserde(
            rename = "annotation",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Annotation {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "appinfo", prefix = "xs")]
            pub appinfo: Vec<AppInfo>,
            #[yaserde(rename = "documentation", prefix = "xs")]
            pub documentation: Vec<Documentation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Annotation {
            #[inline]
            fn clone(&self) -> Annotation {
                Annotation {
                    id: ::core::clone::Clone::clone(&self.id),
                    appinfo: ::core::clone::Clone::clone(&self.appinfo),
                    documentation: ::core::clone::Clone::clone(&self.documentation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Annotation {
            #[inline]
            fn default() -> Annotation {
                Annotation {
                    id: ::core::default::Default::default(),
                    appinfo: ::core::default::Default::default(),
                    documentation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Annotation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Annotation",
                    "id",
                    &self.id,
                    "appinfo",
                    &self.appinfo,
                    "documentation",
                    &&self.documentation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Annotation {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Annotation {
            #[inline]
            fn eq(&self, other: &Annotation) -> bool {
                self.id == other.id && self.appinfo == other.appinfo
                    && self.documentation == other.documentation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Annotation: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Annotation {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("annotation"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Annotation",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __appinfo_value: ::std::vec::Vec<AppInfo> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __documentation_value: ::std::vec::Vec<Documentation> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Annotation",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::annotation",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "appinfo") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <AppInfo as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __appinfo_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "documentation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Documentation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __documentation_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Annotation",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Annotation {
                        id: __id_value,
                        appinfo: __appinfo_value,
                        documentation: __documentation_value,
                    })
                }
            }
        };
        /**
 * <appinfo
 *  source = anyURI
 *  {any attributes with non-schema namespace . . .}>
 *    Content: ({any})*
 * </appinfo>
 */
        #[yaserde(
            rename = "appinfo",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct AppInfo {
            #[yaserde(attribute)]
            pub source: Option<String>,
            #[yaserde(text)]
            pub text: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AppInfo {
            #[inline]
            fn clone(&self) -> AppInfo {
                AppInfo {
                    source: ::core::clone::Clone::clone(&self.source),
                    text: ::core::clone::Clone::clone(&self.text),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AppInfo {
            #[inline]
            fn default() -> AppInfo {
                AppInfo {
                    source: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AppInfo {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "AppInfo",
                    "source",
                    &self.source,
                    "text",
                    &&self.text,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AppInfo {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AppInfo {
            #[inline]
            fn eq(&self, other: &AppInfo) -> bool {
                self.source == other.source && self.text == other.text
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_AppInfo: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for AppInfo {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("appinfo"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "AppInfo",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __source_value = None;
                    #[allow(unused_mut)]
                    let mut __text_value: Option<::std::string::String> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Source_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Source_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Text_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Text_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "AppInfo",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::annotation",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("", "text") => {
                                            let visitor = __Visitor_Text_ {};
                                            if let Some(namespace) = name.namespace.as_ref() {
                                                match namespace.as_str() {
                                                    bad_namespace => {
                                                        let msg = ::alloc::__export::must_use({
                                                            let res = ::alloc::fmt::format(
                                                                format_args!(
                                                                    "bad namespace for {0}, found {1}",
                                                                    name.local_name.as_str(),
                                                                    bad_namespace,
                                                                ),
                                                            );
                                                            res
                                                        });
                                                        return Err(msg);
                                                    }
                                                }
                                            }
                                            let result = reader
                                                .read_inner_value::<
                                                    ::std::string::String,
                                                    _,
                                                >(|reader| {
                                                    if let ::std::result::Result::Ok(
                                                        ::yaserde::__xml::reader::XmlEvent::Characters(s),
                                                    ) = reader.peek()
                                                    {
                                                        let val = visitor.visit_str(&s);
                                                        let _event = reader.next_event()?;
                                                        val
                                                    } else {
                                                        ::std::result::Result::Err(
                                                            ::alloc::__export::must_use({
                                                                let res = ::alloc::fmt::format(
                                                                    format_args!("unable to parse content for {0}", "text"),
                                                                );
                                                                res
                                                            }),
                                                        )
                                                    }
                                                });
                                            if let ::std::result::Result::Ok(value) = result {
                                                __text_value = ::std::option::Option::Some(value);
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "source" {
                                            let visitor = __Visitor_Attribute_Source_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __source_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                __text_value = Some(text_content.to_owned());
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "AppInfo",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(AppInfo {
                        source: __source_value,
                        text: __text_value
                            .ok_or_else(|| {
                                "text is a required field of AppInfo".to_string()
                            })?,
                    })
                }
            }
        };
        /**
 * <documentation
 *  source = anyURI
 *  xml:lang = language
 *  {any attributes with non-schema namespace . . .}>
 *    Content: ({any})*
 * </documentation>
 */
        #[yaserde(
            rename = "documentation",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Documentation {
            #[yaserde(attribute)]
            pub source: Option<String>,
            #[yaserde(attribute, rename = "lang", prefix = "xml")]
            pub lang: Option<String>,
            #[yaserde(text)]
            pub text: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Documentation {
            #[inline]
            fn clone(&self) -> Documentation {
                Documentation {
                    source: ::core::clone::Clone::clone(&self.source),
                    lang: ::core::clone::Clone::clone(&self.lang),
                    text: ::core::clone::Clone::clone(&self.text),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Documentation {
            #[inline]
            fn default() -> Documentation {
                Documentation {
                    source: ::core::default::Default::default(),
                    lang: ::core::default::Default::default(),
                    text: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Documentation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Documentation",
                    "source",
                    &self.source,
                    "lang",
                    &self.lang,
                    "text",
                    &&self.text,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Documentation {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Documentation {
            #[inline]
            fn eq(&self, other: &Documentation) -> bool {
                self.source == other.source && self.lang == other.lang
                    && self.text == other.text
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Documentation: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Documentation {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("documentation"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Documentation",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __source_value = None;
                    #[allow(unused_mut)]
                    let mut __lang_value = None;
                    #[allow(unused_mut)]
                    let mut __text_value: Option<::std::string::String> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Source_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Source_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Xml_Lang_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Xml_Lang_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Text_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Text_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Documentation",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::annotation",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("", "text") => {
                                            let visitor = __Visitor_Text_ {};
                                            if let Some(namespace) = name.namespace.as_ref() {
                                                match namespace.as_str() {
                                                    bad_namespace => {
                                                        let msg = ::alloc::__export::must_use({
                                                            let res = ::alloc::fmt::format(
                                                                format_args!(
                                                                    "bad namespace for {0}, found {1}",
                                                                    name.local_name.as_str(),
                                                                    bad_namespace,
                                                                ),
                                                            );
                                                            res
                                                        });
                                                        return Err(msg);
                                                    }
                                                }
                                            }
                                            let result = reader
                                                .read_inner_value::<
                                                    ::std::string::String,
                                                    _,
                                                >(|reader| {
                                                    if let ::std::result::Result::Ok(
                                                        ::yaserde::__xml::reader::XmlEvent::Characters(s),
                                                    ) = reader.peek()
                                                    {
                                                        let val = visitor.visit_str(&s);
                                                        let _event = reader.next_event()?;
                                                        val
                                                    } else {
                                                        ::std::result::Result::Err(
                                                            ::alloc::__export::must_use({
                                                                let res = ::alloc::fmt::format(
                                                                    format_args!("unable to parse content for {0}", "text"),
                                                                );
                                                                res
                                                            }),
                                                        )
                                                    }
                                                });
                                            if let ::std::result::Result::Ok(value) = result {
                                                __text_value = ::std::option::Option::Some(value);
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "source" {
                                            let visitor = __Visitor_Attribute_Source_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __source_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "lang" {
                                            let visitor = __Visitor_Attribute_Xml_Lang_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __lang_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                __text_value = Some(text_content.to_owned());
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Documentation",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::annotation",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Documentation {
                        source: __source_value,
                        lang: __lang_value,
                        text: __text_value
                            .ok_or_else(|| {
                                "text is a required field of Documentation".to_string()
                            })?,
                    })
                }
            }
        };
    }
    pub mod attribute {
        use yaserde::*;
        use crate::xsd::{
            types::SimpleType, annotation::Annotation, type_def::{Form, ProcessContents},
            common_type::QName,
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub struct AttributeType {
            #[yaserde(rename = "attribute", prefix = "xs")]
            pub attributes: Vec<Attribute>,
            #[yaserde(rename = "attributeGroup", prefix = "xs")]
            pub attribute_groups: Vec<AttributeGroup>,
            #[yaserde(rename = "anyAttribute", prefix = "xs")]
            pub any_attributes: Option<AnyAttribute>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AttributeType {
            #[inline]
            fn clone(&self) -> AttributeType {
                AttributeType {
                    attributes: ::core::clone::Clone::clone(&self.attributes),
                    attribute_groups: ::core::clone::Clone::clone(
                        &self.attribute_groups,
                    ),
                    any_attributes: ::core::clone::Clone::clone(&self.any_attributes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AttributeType {
            #[inline]
            fn default() -> AttributeType {
                AttributeType {
                    attributes: ::core::default::Default::default(),
                    attribute_groups: ::core::default::Default::default(),
                    any_attributes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AttributeType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "AttributeType",
                    "attributes",
                    &self.attributes,
                    "attribute_groups",
                    &self.attribute_groups,
                    "any_attributes",
                    &&self.any_attributes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AttributeType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AttributeType {
            #[inline]
            fn eq(&self, other: &AttributeType) -> bool {
                self.attributes == other.attributes
                    && self.attribute_groups == other.attribute_groups
                    && self.any_attributes == other.any_attributes
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_AttributeType: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for AttributeType {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("AttributeType"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "AttributeType",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __attributes_value: ::std::vec::Vec<Attribute> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __attribute_groups_value: ::std::vec::Vec<AttributeGroup> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __any_attributes_value = None;
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "AttributeType",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "attribute") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Attribute as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attributes_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "attributeGroup") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <AttributeGroup as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attribute_groups_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "anyAttribute") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <AnyAttribute as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_attributes_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {}
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "AttributeType",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(AttributeType {
                        attributes: __attributes_value,
                        attribute_groups: __attribute_groups_value,
                        any_attributes: __any_attributes_value,
                    })
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub struct RefAttributeType {
            #[yaserde(rename = "attribute", prefix = "xs")]
            pub attributes: Vec<Attribute>,
            #[yaserde(rename = "attributeGroup", prefix = "xs")]
            pub attribute_groups: Vec<RefAttributeGroup>,
            #[yaserde(rename = "anyAttribute", prefix = "xs")]
            pub any_attributes: Option<AnyAttribute>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RefAttributeType {
            #[inline]
            fn clone(&self) -> RefAttributeType {
                RefAttributeType {
                    attributes: ::core::clone::Clone::clone(&self.attributes),
                    attribute_groups: ::core::clone::Clone::clone(
                        &self.attribute_groups,
                    ),
                    any_attributes: ::core::clone::Clone::clone(&self.any_attributes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RefAttributeType {
            #[inline]
            fn default() -> RefAttributeType {
                RefAttributeType {
                    attributes: ::core::default::Default::default(),
                    attribute_groups: ::core::default::Default::default(),
                    any_attributes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RefAttributeType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "RefAttributeType",
                    "attributes",
                    &self.attributes,
                    "attribute_groups",
                    &self.attribute_groups,
                    "any_attributes",
                    &&self.any_attributes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RefAttributeType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RefAttributeType {
            #[inline]
            fn eq(&self, other: &RefAttributeType) -> bool {
                self.attributes == other.attributes
                    && self.attribute_groups == other.attribute_groups
                    && self.any_attributes == other.any_attributes
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_RefAttributeType: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for RefAttributeType {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("RefAttributeType"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "RefAttributeType",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __attributes_value: ::std::vec::Vec<Attribute> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __attribute_groups_value: ::std::vec::Vec<
                        RefAttributeGroup,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __any_attributes_value = None;
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "RefAttributeType",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "attribute") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Attribute as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attributes_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "attributeGroup") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <RefAttributeGroup as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attribute_groups_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "anyAttribute") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <AnyAttribute as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_attributes_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {}
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "RefAttributeType",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(RefAttributeType {
                        attributes: __attributes_value,
                        attribute_groups: __attribute_groups_value,
                        any_attributes: __any_attributes_value,
                    })
                }
            }
        };
        /**
 * <attribute
 *  default = string
 *  fixed = string
 *  form = (qualified | unqualified)
 *  id = ID
 *  name = NCName
 *  ref = QName
 *  targetNamespace = anyURI
 *  type = QName
 *  use = (optional | prohibited | required) : optional
 *  inheritable = boolean
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, simpleType?)
 *</attribute>
 */
        #[yaserde(
            rename = "attribute",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Attribute {
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute)]
            pub default: Option<String>,
            #[yaserde(attribute)]
            pub fixed: Option<String>,
            #[yaserde(attribute)]
            pub form: Option<Form>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            target_namespace: Option<String>,
            #[yaserde(attribute, rename = "type")]
            pub type_v: Option<String>,
            #[yaserde(rename = "use", attribute, default = "default_use")]
            pub use_v: Use,
            #[yaserde(rename = "ref", attribute)]
            pub ref_v: Option<QName>,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            pub simple_type: Option<SimpleType>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(attribute)]
            pub inheritable: Option<bool>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Attribute {
            #[inline]
            fn clone(&self) -> Attribute {
                Attribute {
                    name: ::core::clone::Clone::clone(&self.name),
                    default: ::core::clone::Clone::clone(&self.default),
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    form: ::core::clone::Clone::clone(&self.form),
                    id: ::core::clone::Clone::clone(&self.id),
                    target_namespace: ::core::clone::Clone::clone(
                        &self.target_namespace,
                    ),
                    type_v: ::core::clone::Clone::clone(&self.type_v),
                    use_v: ::core::clone::Clone::clone(&self.use_v),
                    ref_v: ::core::clone::Clone::clone(&self.ref_v),
                    simple_type: ::core::clone::Clone::clone(&self.simple_type),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    inheritable: ::core::clone::Clone::clone(&self.inheritable),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Attribute {
            #[inline]
            fn default() -> Attribute {
                Attribute {
                    name: ::core::default::Default::default(),
                    default: ::core::default::Default::default(),
                    fixed: ::core::default::Default::default(),
                    form: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    target_namespace: ::core::default::Default::default(),
                    type_v: ::core::default::Default::default(),
                    use_v: ::core::default::Default::default(),
                    ref_v: ::core::default::Default::default(),
                    simple_type: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    inheritable: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Attribute {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "name",
                    "default",
                    "fixed",
                    "form",
                    "id",
                    "target_namespace",
                    "type_v",
                    "use_v",
                    "ref_v",
                    "simple_type",
                    "annotation",
                    "inheritable",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.name,
                    &self.default,
                    &self.fixed,
                    &self.form,
                    &self.id,
                    &self.target_namespace,
                    &self.type_v,
                    &self.use_v,
                    &self.ref_v,
                    &self.simple_type,
                    &self.annotation,
                    &&self.inheritable,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Attribute",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Attribute {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Attribute {
            #[inline]
            fn eq(&self, other: &Attribute) -> bool {
                self.name == other.name && self.default == other.default
                    && self.fixed == other.fixed && self.form == other.form
                    && self.id == other.id
                    && self.target_namespace == other.target_namespace
                    && self.type_v == other.type_v && self.use_v == other.use_v
                    && self.ref_v == other.ref_v && self.simple_type == other.simple_type
                    && self.annotation == other.annotation
                    && self.inheritable == other.inheritable
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Attribute: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Attribute {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("attribute"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Attribute",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __default_value = None;
                    #[allow(unused_mut)]
                    let mut __fixed_value = None;
                    #[allow(unused_mut)]
                    let mut __form_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __target_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __type_v_value = None;
                    #[allow(unused_mut)]
                    let mut __use_v_value: Option<Use> = None;
                    #[allow(unused_mut)]
                    let mut __ref_v_value = None;
                    #[allow(unused_mut)]
                    let mut __simple_type_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __inheritable_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Default_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Default_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Form_Form;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Form_Form {
                        type Value = Form;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Form>", v, "</Form>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_TargetNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_TargetNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Type_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Type_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Use_Use;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Use_Use {
                        type Value = Use;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Use>", v, "</Use>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Ref_QName;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Ref_QName {
                        type Value = QName;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<QName>", v, "</QName>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Inheritable_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Inheritable_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Attribute",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_type_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "default" {
                                            let visitor = __Visitor_Attribute_Default_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __default_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __fixed_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "form" {
                                            let visitor = __Visitor_Attribute_Form_Form {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __form_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "target_namespace" {
                                            let visitor = __Visitor_Attribute_TargetNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __target_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "type" {
                                            let visitor = __Visitor_Attribute_Type_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __type_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "use" {
                                            let visitor = __Visitor_Attribute_Use_Use {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __use_v_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "ref" {
                                            let visitor = __Visitor_Attribute_Ref_QName {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __ref_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "inheritable" {
                                            let visitor = __Visitor_Attribute_Inheritable_ {
                                            };
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __inheritable_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Attribute",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Attribute {
                        name: __name_value,
                        default: __default_value,
                        fixed: __fixed_value,
                        form: __form_value,
                        id: __id_value,
                        target_namespace: __target_namespace_value,
                        type_v: __type_v_value,
                        use_v: __use_v_value.unwrap_or_else(|| default_use()),
                        ref_v: __ref_v_value,
                        simple_type: __simple_type_value,
                        annotation: __annotation_value,
                        inheritable: __inheritable_value,
                    })
                }
            }
        };
        /**
 * <attributeGroup
 *   id = ID
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </attributeGroup>
 * <attributeGroup
 *   id = ID
 *   name = NCName
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?))
 * </attributeGroup>
 */
        #[yaserde(
            rename = "attributeGroup",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct AttributeGroup {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute, rename = "ref")]
            pub ref_v: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub attributes: RefAttributeType,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AttributeGroup {
            #[inline]
            fn clone(&self) -> AttributeGroup {
                AttributeGroup {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    ref_v: ::core::clone::Clone::clone(&self.ref_v),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    attributes: ::core::clone::Clone::clone(&self.attributes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AttributeGroup {
            #[inline]
            fn default() -> AttributeGroup {
                AttributeGroup {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    ref_v: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    attributes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AttributeGroup {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "AttributeGroup",
                    "id",
                    &self.id,
                    "name",
                    &self.name,
                    "ref_v",
                    &self.ref_v,
                    "annotation",
                    &self.annotation,
                    "attributes",
                    &&self.attributes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AttributeGroup {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AttributeGroup {
            #[inline]
            fn eq(&self, other: &AttributeGroup) -> bool {
                self.id == other.id && self.name == other.name
                    && self.ref_v == other.ref_v && self.annotation == other.annotation
                    && self.attributes == other.attributes
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_AttributeGroup: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for AttributeGroup {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("attributeGroup"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "AttributeGroup",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __ref_v_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __attributes_value: Option<RefAttributeType> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Ref_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Ref_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "AttributeGroup",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "ref" {
                                            let visitor = __Visitor_Attribute_Ref_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __ref_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __attributes_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "AttributeGroup",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(AttributeGroup {
                        id: __id_value,
                        name: __name_value,
                        ref_v: __ref_v_value,
                        annotation: __annotation_value,
                        attributes: __attributes_value
                            .ok_or_else(|| {
                                "attributes is a required field of AttributeGroup"
                                    .to_string()
                            })?,
                    })
                }
            }
        };
        /**
 * <attributeGroup
 *   id = ID
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?)
 * </attributeGroup>
 */
        #[yaserde(
            rename = "attributeGroup",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct RefAttributeGroup {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "ref")]
            pub ref_v: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RefAttributeGroup {
            #[inline]
            fn clone(&self) -> RefAttributeGroup {
                RefAttributeGroup {
                    id: ::core::clone::Clone::clone(&self.id),
                    ref_v: ::core::clone::Clone::clone(&self.ref_v),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RefAttributeGroup {
            #[inline]
            fn default() -> RefAttributeGroup {
                RefAttributeGroup {
                    id: ::core::default::Default::default(),
                    ref_v: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RefAttributeGroup {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "RefAttributeGroup",
                    "id",
                    &self.id,
                    "ref_v",
                    &self.ref_v,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RefAttributeGroup {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RefAttributeGroup {
            #[inline]
            fn eq(&self, other: &RefAttributeGroup) -> bool {
                self.id == other.id && self.ref_v == other.ref_v
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_RefAttributeGroup: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for RefAttributeGroup {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("attributeGroup"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "RefAttributeGroup",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __ref_v_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Ref_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Ref_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "RefAttributeGroup",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "ref" {
                                            let visitor = __Visitor_Attribute_Ref_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __ref_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "RefAttributeGroup",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(RefAttributeGroup {
                        id: __id_value,
                        ref_v: __ref_v_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        fn default_use() -> Use {
            Use::Optional
        }
        /**
 * <anyAttribute
 *   id = ID
 *   namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )
 *   notNamespace = List of (anyURI | (##targetNamespace | ##local))
 *   notQName = List of (QName | ##defined)
 *   processContents = (lax | skip | strict) : strict
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </anyAttribute>
 */
        #[yaserde(
            rename = "anyAttribute",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct AnyAttribute {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub namespace: Option<String>,
            #[yaserde(attribute, rename = "notNamespace")]
            pub not_namespace: Vec<String>,
            #[yaserde(attribute, rename = "notQName")]
            pub not_qname: Vec<String>,
            #[yaserde(attribute, rename = "processContents", default)]
            pub process_contents: ProcessContents,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AnyAttribute {
            #[inline]
            fn clone(&self) -> AnyAttribute {
                AnyAttribute {
                    id: ::core::clone::Clone::clone(&self.id),
                    namespace: ::core::clone::Clone::clone(&self.namespace),
                    not_namespace: ::core::clone::Clone::clone(&self.not_namespace),
                    not_qname: ::core::clone::Clone::clone(&self.not_qname),
                    process_contents: ::core::clone::Clone::clone(
                        &self.process_contents,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AnyAttribute {
            #[inline]
            fn default() -> AnyAttribute {
                AnyAttribute {
                    id: ::core::default::Default::default(),
                    namespace: ::core::default::Default::default(),
                    not_namespace: ::core::default::Default::default(),
                    not_qname: ::core::default::Default::default(),
                    process_contents: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AnyAttribute {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "namespace",
                    "not_namespace",
                    "not_qname",
                    "process_contents",
                    "annotation",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.namespace,
                    &self.not_namespace,
                    &self.not_qname,
                    &self.process_contents,
                    &&self.annotation,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "AnyAttribute",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AnyAttribute {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AnyAttribute {
            #[inline]
            fn eq(&self, other: &AnyAttribute) -> bool {
                self.id == other.id && self.namespace == other.namespace
                    && self.not_namespace == other.not_namespace
                    && self.not_qname == other.not_qname
                    && self.process_contents == other.process_contents
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_AnyAttribute: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for AnyAttribute {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("anyAttribute"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "AnyAttribute",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __not_namespace_value: ::std::vec::Vec<
                        ::std::string::String,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __not_qname_value: ::std::vec::Vec<::std::string::String> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __process_contents_value: Option<ProcessContents> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Namespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Namespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_NotNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_NotNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_NotQName_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_NotQName_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_ProcessContents_ProcessContents;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_ProcessContents_ProcessContents {
                        type Value = ProcessContents;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}{1}{2}",
                                        "<ProcessContents>",
                                        v,
                                        "</ProcessContents>",
                                    ),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "AnyAttribute",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "namespace" {
                                            let visitor = __Visitor_Attribute_Namespace_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __namespace_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "notNamespace" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_NotNamespace_ {
                                                };
                                                let value = visitor.visit_str(value)?;
                                                __not_namespace_value.push(value);
                                            }
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "notQName" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_NotQName_ {};
                                                let value = visitor.visit_str(value)?;
                                                __not_qname_value.push(value);
                                            }
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "processContents" {
                                            let visitor = __Visitor_Attribute_ProcessContents_ProcessContents {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __process_contents_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "AnyAttribute",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(AnyAttribute {
                        id: __id_value,
                        namespace: __namespace_value,
                        not_namespace: __not_namespace_value,
                        not_qname: __not_qname_value,
                        process_contents: __process_contents_value
                            .ok_or_else(|| {
                                "process_contents is a required field of AnyAttribute"
                                    .to_string()
                            })?,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        pub enum Use {
            #[default]
            #[yaserde(rename = "optional")]
            Optional,
            #[yaserde(rename = "prohibited")]
            Prohibited,
            #[yaserde(rename = "required")]
            Required,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Use {
            #[inline]
            fn clone(&self) -> Use {
                match self {
                    Use::Optional => Use::Optional,
                    Use::Prohibited => Use::Prohibited,
                    Use::Required => Use::Required,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Use {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Use::Optional => "Optional",
                        Use::Prohibited => "Prohibited",
                        Use::Required => "Required",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Use {
            #[inline]
            fn default() -> Use {
                Self::Optional
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Use {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Use {
            #[inline]
            fn eq(&self, other: &Use) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Use: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Use {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (::std::string::String::from("Use"), ::std::option::Option::None)
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "Use",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "Use",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::attribute",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "optional" => {
                                        enum_value = ::std::option::Option::Some(Use::Optional);
                                        break;
                                    }
                                    "prohibited" => {
                                        enum_value = ::std::option::Option::Some(Use::Prohibited);
                                        break;
                                    }
                                    "required" => {
                                        enum_value = ::std::option::Option::Some(Use::Required);
                                        break;
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "optional" => {
                                            enum_value = ::std::option::Option::Some(Use::Optional);
                                            break;
                                        }
                                        "prohibited" => {
                                            enum_value = ::std::option::Option::Some(Use::Prohibited);
                                            break;
                                        }
                                        "required" => {
                                            enum_value = ::std::option::Option::Some(Use::Required);
                                            break;
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("Enum {0} @ {1}: success", "Use", start_depth),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::attribute",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value.unwrap_or(<Use as ::std::default::Default>::default()),
                    )
                }
            }
        };
    }
    pub mod content {
        use yaserde::*;
        use crate::xsd::{
            annotation::Annotation, any::Any, attribute::AttributeType,
            type_def::{
                Assert, Assertion, ComplexChildren, Enumeration, FractionDigits, Length,
                MaxExclusive, MaxInclusive, MaxLength, MinExclusive, MinInclusive,
                MinLength, Pattern, TotalDigits, WhiteSpace,
            },
            types::SimpleType,
        };
        /**
 * <complexContent
 *   id = ID
 *   mixed = boolean
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (restriction | extension))
 * </complexContent>
 */
        #[yaserde(
            rename = "complexContent",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct ComplexContent {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub mixed: Option<bool>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub value: ComplexContextRestrictionOrExtrension,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexContent {
            #[inline]
            fn clone(&self) -> ComplexContent {
                ComplexContent {
                    id: ::core::clone::Clone::clone(&self.id),
                    mixed: ::core::clone::Clone::clone(&self.mixed),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexContent {
            #[inline]
            fn default() -> ComplexContent {
                ComplexContent {
                    id: ::core::default::Default::default(),
                    mixed: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexContent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ComplexContent",
                    "id",
                    &self.id,
                    "mixed",
                    &self.mixed,
                    "annotation",
                    &self.annotation,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexContent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexContent {
            #[inline]
            fn eq(&self, other: &ComplexContent) -> bool {
                self.id == other.id && self.mixed == other.mixed
                    && self.annotation == other.annotation && self.value == other.value
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexContent: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexContent {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("complexContent"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "ComplexContent",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __mixed_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value: Option<
                        ComplexContextRestrictionOrExtrension,
                    > = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Mixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Mixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "ComplexContent",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "mixed" {
                                            let visitor = __Visitor_Attribute_Mixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __mixed_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __value_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "ComplexContent",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(ComplexContent {
                        id: __id_value,
                        mixed: __mixed_value,
                        annotation: __annotation_value,
                        value: __value_value
                            .ok_or_else(|| {
                                "value is a required field of ComplexContent".to_string()
                            })?,
                    })
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum ComplexContextRestrictionOrExtrension {
            #[default]
            Undefined,
            #[yaserde(rename = "restriction", prefix = "xs")]
            Restriction(ComplexContentRestriction),
            #[yaserde(rename = "extension", prefix = "xs")]
            Extension(ComplexContentExtension),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexContextRestrictionOrExtrension {
            #[inline]
            fn clone(&self) -> ComplexContextRestrictionOrExtrension {
                match self {
                    ComplexContextRestrictionOrExtrension::Undefined => {
                        ComplexContextRestrictionOrExtrension::Undefined
                    }
                    ComplexContextRestrictionOrExtrension::Restriction(__self_0) => {
                        ComplexContextRestrictionOrExtrension::Restriction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ComplexContextRestrictionOrExtrension::Extension(__self_0) => {
                        ComplexContextRestrictionOrExtrension::Extension(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexContextRestrictionOrExtrension {
            #[inline]
            fn default() -> ComplexContextRestrictionOrExtrension {
                Self::Undefined
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexContextRestrictionOrExtrension {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ComplexContextRestrictionOrExtrension::Undefined => {
                        ::core::fmt::Formatter::write_str(f, "Undefined")
                    }
                    ComplexContextRestrictionOrExtrension::Restriction(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Restriction",
                            &__self_0,
                        )
                    }
                    ComplexContextRestrictionOrExtrension::Extension(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Extension",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq
        for ComplexContextRestrictionOrExtrension {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexContextRestrictionOrExtrension {
            #[inline]
            fn eq(&self, other: &ComplexContextRestrictionOrExtrension) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            ComplexContextRestrictionOrExtrension::Restriction(__self_0),
                            ComplexContextRestrictionOrExtrension::Restriction(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexContextRestrictionOrExtrension::Extension(__self_0),
                            ComplexContextRestrictionOrExtrension::Extension(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexContextRestrictionOrExtrension: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexContextRestrictionOrExtrension {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from(
                                "ComplexContextRestrictionOrExtrension",
                            ),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "ComplexContextRestrictionOrExtrension",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "ComplexContextRestrictionOrExtrension",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "Undefined" => {
                                        enum_value = ::std::option::Option::Some(
                                            ComplexContextRestrictionOrExtrension::Undefined,
                                        );
                                        break;
                                    }
                                    "restriction" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = ComplexContentRestriction;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "ComplexContentRestriction"
                                                    + ">" + v + "</" + "ComplexContentRestriction" + ">";
                                                let value: ::std::result::Result<
                                                    ComplexContentRestriction,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <ComplexContentRestriction as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexContextRestrictionOrExtrension::Restriction(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "extension" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = ComplexContentExtension;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "ComplexContentExtension"
                                                    + ">" + v + "</" + "ComplexContentExtension" + ">";
                                                let value: ::std::result::Result<
                                                    ComplexContentExtension,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <ComplexContentExtension as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexContextRestrictionOrExtrension::Extension(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "Undefined" => {
                                            enum_value = ::std::option::Option::Some(
                                                ComplexContextRestrictionOrExtrension::Undefined,
                                            );
                                            break;
                                        }
                                        "restriction" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = ComplexContentRestriction;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "ComplexContentRestriction"
                                                        + ">" + v + "</" + "ComplexContentRestriction" + ">";
                                                    let value: ::std::result::Result<
                                                        ComplexContentRestriction,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <ComplexContentRestriction as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexContextRestrictionOrExtrension::Restriction(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "extension" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = ComplexContentExtension;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "ComplexContentExtension"
                                                        + ">" + v + "</" + "ComplexContentExtension" + ">";
                                                    let value: ::std::result::Result<
                                                        ComplexContentExtension,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <ComplexContentExtension as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexContextRestrictionOrExtrension::Extension(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "ComplexContextRestrictionOrExtrension",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <ComplexContextRestrictionOrExtrension as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        /**
 * <restriction
 *   base = QName
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, openContent?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), assert*)
 * </restriction>
 */
        #[yaserde(
            rename = "restriction",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct ComplexContentRestriction {
            #[yaserde(attribute)]
            pub base: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "openContet", prefix = "xs")]
            pub open_context: Option<OpenContent>,
            #[yaserde(flatten)]
            pub complex_children: ComplexChildren,
            #[yaserde(flatten)]
            pub attribute: AttributeType,
            #[yaserde(rename = "assert", prefix = "xs")]
            pub assert: Vec<Assert>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexContentRestriction {
            #[inline]
            fn clone(&self) -> ComplexContentRestriction {
                ComplexContentRestriction {
                    base: ::core::clone::Clone::clone(&self.base),
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    open_context: ::core::clone::Clone::clone(&self.open_context),
                    complex_children: ::core::clone::Clone::clone(
                        &self.complex_children,
                    ),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    assert: ::core::clone::Clone::clone(&self.assert),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexContentRestriction {
            #[inline]
            fn default() -> ComplexContentRestriction {
                ComplexContentRestriction {
                    base: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    open_context: ::core::default::Default::default(),
                    complex_children: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    assert: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexContentRestriction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "id",
                    "annotation",
                    "open_context",
                    "complex_children",
                    "attribute",
                    "assert",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.id,
                    &self.annotation,
                    &self.open_context,
                    &self.complex_children,
                    &self.attribute,
                    &&self.assert,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ComplexContentRestriction",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexContentRestriction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexContentRestriction {
            #[inline]
            fn eq(&self, other: &ComplexContentRestriction) -> bool {
                self.base == other.base && self.id == other.id
                    && self.annotation == other.annotation
                    && self.open_context == other.open_context
                    && self.complex_children == other.complex_children
                    && self.attribute == other.attribute && self.assert == other.assert
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexContentRestriction: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexContentRestriction {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("restriction"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "ComplexContentRestriction",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __base_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __open_context_value = None;
                    #[allow(unused_mut)]
                    let mut __complex_children_value: Option<ComplexChildren> = None;
                    #[allow(unused_mut)]
                    let mut __attribute_value: Option<AttributeType> = None;
                    #[allow(unused_mut)]
                    let mut __assert_value: ::std::vec::Vec<Assert> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Base_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Base_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "ComplexContentRestriction",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "openContet") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <OpenContent as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __open_context_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assert") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assert as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assert_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "base" {
                                            let visitor = __Visitor_Attribute_Base_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __base_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __complex_children_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                        __attribute_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "ComplexContentRestriction",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(ComplexContentRestriction {
                        base: __base_value,
                        id: __id_value,
                        annotation: __annotation_value,
                        open_context: __open_context_value,
                        complex_children: __complex_children_value
                            .ok_or_else(|| {
                                "complex_children is a required field of ComplexContentRestriction"
                                    .to_string()
                            })?,
                        attribute: __attribute_value
                            .ok_or_else(|| {
                                "attribute is a required field of ComplexContentRestriction"
                                    .to_string()
                            })?,
                        assert: __assert_value,
                    })
                }
            }
        };
        /**
 * <extension
 *   base = QName
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, openContent?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), assert*))
 * </extension>
 */
        #[yaserde(
            rename = "extension",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct ComplexContentExtension {
            #[yaserde(attribute)]
            pub base: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "openContet", prefix = "xs")]
            pub open_context: Option<OpenContent>,
            #[yaserde(flatten)]
            pub attribute: AttributeType,
            #[yaserde(flatten)]
            pub complex_children: ComplexChildren,
            #[yaserde(rename = "assert", prefix = "xs")]
            pub assert: Vec<Assert>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexContentExtension {
            #[inline]
            fn clone(&self) -> ComplexContentExtension {
                ComplexContentExtension {
                    base: ::core::clone::Clone::clone(&self.base),
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    open_context: ::core::clone::Clone::clone(&self.open_context),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    complex_children: ::core::clone::Clone::clone(
                        &self.complex_children,
                    ),
                    assert: ::core::clone::Clone::clone(&self.assert),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexContentExtension {
            #[inline]
            fn default() -> ComplexContentExtension {
                ComplexContentExtension {
                    base: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    open_context: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    complex_children: ::core::default::Default::default(),
                    assert: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexContentExtension {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "id",
                    "annotation",
                    "open_context",
                    "attribute",
                    "complex_children",
                    "assert",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.id,
                    &self.annotation,
                    &self.open_context,
                    &self.attribute,
                    &self.complex_children,
                    &&self.assert,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ComplexContentExtension",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexContentExtension {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexContentExtension {
            #[inline]
            fn eq(&self, other: &ComplexContentExtension) -> bool {
                self.base == other.base && self.id == other.id
                    && self.annotation == other.annotation
                    && self.open_context == other.open_context
                    && self.attribute == other.attribute
                    && self.complex_children == other.complex_children
                    && self.assert == other.assert
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexContentExtension: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexContentExtension {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("extension"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "ComplexContentExtension",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __base_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __open_context_value = None;
                    #[allow(unused_mut)]
                    let mut __attribute_value: Option<AttributeType> = None;
                    #[allow(unused_mut)]
                    let mut __complex_children_value: Option<ComplexChildren> = None;
                    #[allow(unused_mut)]
                    let mut __assert_value: ::std::vec::Vec<Assert> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Base_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Base_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "ComplexContentExtension",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "openContet") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <OpenContent as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __open_context_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assert") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assert as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assert_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "base" {
                                            let visitor = __Visitor_Attribute_Base_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __base_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __attribute_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                        __complex_children_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "ComplexContentExtension",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(ComplexContentExtension {
                        base: __base_value,
                        id: __id_value,
                        annotation: __annotation_value,
                        open_context: __open_context_value,
                        attribute: __attribute_value
                            .ok_or_else(|| {
                                "attribute is a required field of ComplexContentExtension"
                                    .to_string()
                            })?,
                        complex_children: __complex_children_value
                            .ok_or_else(|| {
                                "complex_children is a required field of ComplexContentExtension"
                                    .to_string()
                            })?,
                        assert: __assert_value,
                    })
                }
            }
        };
        /**
 * <simpleContent
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (restriction | extension))
 * </simpleContent>
 */
        #[yaserde(
            rename = "simpleContent",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct SimpleContent {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub value: SimpleContextRestrictionOrExtrension,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleContent {
            #[inline]
            fn clone(&self) -> SimpleContent {
                SimpleContent {
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleContent {
            #[inline]
            fn default() -> SimpleContent {
                SimpleContent {
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleContent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "SimpleContent",
                    "id",
                    &self.id,
                    "annotation",
                    &self.annotation,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleContent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleContent {
            #[inline]
            fn eq(&self, other: &SimpleContent) -> bool {
                self.id == other.id && self.annotation == other.annotation
                    && self.value == other.value
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleContent: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleContent {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("simpleContent"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "SimpleContent",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value: Option<
                        SimpleContextRestrictionOrExtrension,
                    > = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "SimpleContent",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __value_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "SimpleContent",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(SimpleContent {
                        id: __id_value,
                        annotation: __annotation_value,
                        value: __value_value
                            .ok_or_else(|| {
                                "value is a required field of SimpleContent".to_string()
                            })?,
                    })
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum SimpleContextRestrictionOrExtrension {
            #[default]
            Undefined,
            #[yaserde(rename = "restriction", prefix = "xs")]
            Restriction(SimpleContentRestriction),
            #[yaserde(rename = "extension", prefix = "xs")]
            Extension(SimpleContentExtension),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleContextRestrictionOrExtrension {
            #[inline]
            fn clone(&self) -> SimpleContextRestrictionOrExtrension {
                match self {
                    SimpleContextRestrictionOrExtrension::Undefined => {
                        SimpleContextRestrictionOrExtrension::Undefined
                    }
                    SimpleContextRestrictionOrExtrension::Restriction(__self_0) => {
                        SimpleContextRestrictionOrExtrension::Restriction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SimpleContextRestrictionOrExtrension::Extension(__self_0) => {
                        SimpleContextRestrictionOrExtrension::Extension(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleContextRestrictionOrExtrension {
            #[inline]
            fn default() -> SimpleContextRestrictionOrExtrension {
                Self::Undefined
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleContextRestrictionOrExtrension {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SimpleContextRestrictionOrExtrension::Undefined => {
                        ::core::fmt::Formatter::write_str(f, "Undefined")
                    }
                    SimpleContextRestrictionOrExtrension::Restriction(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Restriction",
                            &__self_0,
                        )
                    }
                    SimpleContextRestrictionOrExtrension::Extension(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Extension",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq
        for SimpleContextRestrictionOrExtrension {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleContextRestrictionOrExtrension {
            #[inline]
            fn eq(&self, other: &SimpleContextRestrictionOrExtrension) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            SimpleContextRestrictionOrExtrension::Restriction(__self_0),
                            SimpleContextRestrictionOrExtrension::Restriction(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            SimpleContextRestrictionOrExtrension::Extension(__self_0),
                            SimpleContextRestrictionOrExtrension::Extension(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleContextRestrictionOrExtrension: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleContextRestrictionOrExtrension {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from(
                                "SimpleContextRestrictionOrExtrension",
                            ),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "SimpleContextRestrictionOrExtrension",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "SimpleContextRestrictionOrExtrension",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "Undefined" => {
                                        enum_value = ::std::option::Option::Some(
                                            SimpleContextRestrictionOrExtrension::Undefined,
                                        );
                                        break;
                                    }
                                    "restriction" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = SimpleContentRestriction;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "SimpleContentRestriction"
                                                    + ">" + v + "</" + "SimpleContentRestriction" + ">";
                                                let value: ::std::result::Result<
                                                    SimpleContentRestriction,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <SimpleContentRestriction as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    SimpleContextRestrictionOrExtrension::Restriction(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "extension" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = SimpleContentExtension;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "SimpleContentExtension"
                                                    + ">" + v + "</" + "SimpleContentExtension" + ">";
                                                let value: ::std::result::Result<
                                                    SimpleContentExtension,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <SimpleContentExtension as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    SimpleContextRestrictionOrExtrension::Extension(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "Undefined" => {
                                            enum_value = ::std::option::Option::Some(
                                                SimpleContextRestrictionOrExtrension::Undefined,
                                            );
                                            break;
                                        }
                                        "restriction" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = SimpleContentRestriction;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "SimpleContentRestriction"
                                                        + ">" + v + "</" + "SimpleContentRestriction" + ">";
                                                    let value: ::std::result::Result<
                                                        SimpleContentRestriction,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <SimpleContentRestriction as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        SimpleContextRestrictionOrExtrension::Restriction(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "extension" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = SimpleContentExtension;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "SimpleContentExtension"
                                                        + ">" + v + "</" + "SimpleContentExtension" + ">";
                                                    let value: ::std::result::Result<
                                                        SimpleContentExtension,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <SimpleContentExtension as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        SimpleContextRestrictionOrExtrension::Extension(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "SimpleContextRestrictionOrExtrension",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <SimpleContextRestrictionOrExtrension as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        /** SimpleContent
 * <restriction
 *   base = QName
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern | assertion | {any with namespace: ##other})*)?, ((attribute | attributeGroup)*, anyAttribute?), assert*)
 * </restriction>
 */
        #[yaserde(
            rename = "restriction",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct SimpleContentRestriction {
            #[yaserde(attribute)]
            pub base: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            pub simple_type: Option<SimpleType>,
            #[yaserde(rename = "minExclusive", prefix = "xs")]
            pub min_exclusive: Option<MinExclusive>,
            #[yaserde(rename = "minInclusive", prefix = "xs")]
            pub min_inclusive: Option<MinInclusive>,
            #[yaserde(rename = "maxExclusive", prefix = "xs")]
            pub max_exclusive: Option<MaxExclusive>,
            #[yaserde(rename = "maxInclusive", prefix = "xs")]
            pub max_inclusive: Option<MaxInclusive>,
            #[yaserde(rename = "totalDigits", prefix = "xs")]
            pub total_digits: Option<TotalDigits>,
            #[yaserde(rename = "fractionDigits", prefix = "xs")]
            pub fraction_digits: Option<FractionDigits>,
            #[yaserde(rename = "length", prefix = "xs")]
            pub length: Option<Length>,
            #[yaserde(rename = "minLength", prefix = "xs")]
            pub min_length: Option<MinLength>,
            #[yaserde(rename = "maxLength", prefix = "xs")]
            pub max_length: Option<MaxLength>,
            #[yaserde(rename = "enumeration", prefix = "xs")]
            pub enumeration: Vec<Enumeration>,
            #[yaserde(rename = "whiteSpace", prefix = "xs")]
            pub white_space: Vec<WhiteSpace>,
            #[yaserde(rename = "pattern", prefix = "xs")]
            pub pattern: Vec<Pattern>,
            #[yaserde(rename = "assertion", prefix = "xs")]
            pub assertion: Vec<Assertion>,
            #[yaserde(flatten)]
            pub attribute: AttributeType,
            #[yaserde(rename = "assert", prefix = "xs")]
            pub assert: Vec<Assert>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleContentRestriction {
            #[inline]
            fn clone(&self) -> SimpleContentRestriction {
                SimpleContentRestriction {
                    base: ::core::clone::Clone::clone(&self.base),
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    simple_type: ::core::clone::Clone::clone(&self.simple_type),
                    min_exclusive: ::core::clone::Clone::clone(&self.min_exclusive),
                    min_inclusive: ::core::clone::Clone::clone(&self.min_inclusive),
                    max_exclusive: ::core::clone::Clone::clone(&self.max_exclusive),
                    max_inclusive: ::core::clone::Clone::clone(&self.max_inclusive),
                    total_digits: ::core::clone::Clone::clone(&self.total_digits),
                    fraction_digits: ::core::clone::Clone::clone(&self.fraction_digits),
                    length: ::core::clone::Clone::clone(&self.length),
                    min_length: ::core::clone::Clone::clone(&self.min_length),
                    max_length: ::core::clone::Clone::clone(&self.max_length),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    white_space: ::core::clone::Clone::clone(&self.white_space),
                    pattern: ::core::clone::Clone::clone(&self.pattern),
                    assertion: ::core::clone::Clone::clone(&self.assertion),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    assert: ::core::clone::Clone::clone(&self.assert),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleContentRestriction {
            #[inline]
            fn default() -> SimpleContentRestriction {
                SimpleContentRestriction {
                    base: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    simple_type: ::core::default::Default::default(),
                    min_exclusive: ::core::default::Default::default(),
                    min_inclusive: ::core::default::Default::default(),
                    max_exclusive: ::core::default::Default::default(),
                    max_inclusive: ::core::default::Default::default(),
                    total_digits: ::core::default::Default::default(),
                    fraction_digits: ::core::default::Default::default(),
                    length: ::core::default::Default::default(),
                    min_length: ::core::default::Default::default(),
                    max_length: ::core::default::Default::default(),
                    enumeration: ::core::default::Default::default(),
                    white_space: ::core::default::Default::default(),
                    pattern: ::core::default::Default::default(),
                    assertion: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    assert: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleContentRestriction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "id",
                    "annotation",
                    "simple_type",
                    "min_exclusive",
                    "min_inclusive",
                    "max_exclusive",
                    "max_inclusive",
                    "total_digits",
                    "fraction_digits",
                    "length",
                    "min_length",
                    "max_length",
                    "enumeration",
                    "white_space",
                    "pattern",
                    "assertion",
                    "attribute",
                    "assert",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.id,
                    &self.annotation,
                    &self.simple_type,
                    &self.min_exclusive,
                    &self.min_inclusive,
                    &self.max_exclusive,
                    &self.max_inclusive,
                    &self.total_digits,
                    &self.fraction_digits,
                    &self.length,
                    &self.min_length,
                    &self.max_length,
                    &self.enumeration,
                    &self.white_space,
                    &self.pattern,
                    &self.assertion,
                    &self.attribute,
                    &&self.assert,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SimpleContentRestriction",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleContentRestriction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleContentRestriction {
            #[inline]
            fn eq(&self, other: &SimpleContentRestriction) -> bool {
                self.base == other.base && self.id == other.id
                    && self.annotation == other.annotation
                    && self.simple_type == other.simple_type
                    && self.min_exclusive == other.min_exclusive
                    && self.min_inclusive == other.min_inclusive
                    && self.max_exclusive == other.max_exclusive
                    && self.max_inclusive == other.max_inclusive
                    && self.total_digits == other.total_digits
                    && self.fraction_digits == other.fraction_digits
                    && self.length == other.length && self.min_length == other.min_length
                    && self.max_length == other.max_length
                    && self.enumeration == other.enumeration
                    && self.white_space == other.white_space
                    && self.pattern == other.pattern && self.assertion == other.assertion
                    && self.attribute == other.attribute && self.assert == other.assert
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleContentRestriction: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleContentRestriction {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("restriction"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "SimpleContentRestriction",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __base_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __simple_type_value = None;
                    #[allow(unused_mut)]
                    let mut __min_exclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __min_inclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __max_exclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __max_inclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __total_digits_value = None;
                    #[allow(unused_mut)]
                    let mut __fraction_digits_value = None;
                    #[allow(unused_mut)]
                    let mut __length_value = None;
                    #[allow(unused_mut)]
                    let mut __min_length_value = None;
                    #[allow(unused_mut)]
                    let mut __max_length_value = None;
                    #[allow(unused_mut)]
                    let mut __enumeration_value: ::std::vec::Vec<Enumeration> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __white_space_value: ::std::vec::Vec<WhiteSpace> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __pattern_value: ::std::vec::Vec<Pattern> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __assertion_value: ::std::vec::Vec<Assertion> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __attribute_value: Option<AttributeType> = None;
                    #[allow(unused_mut)]
                    let mut __assert_value: ::std::vec::Vec<Assert> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Base_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Base_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "SimpleContentRestriction",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_type_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minExclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinExclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_exclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minInclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinInclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_inclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxExclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxExclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_exclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxInclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxInclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_inclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "totalDigits") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <TotalDigits as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __total_digits_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "fractionDigits") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <FractionDigits as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __fraction_digits_value = ::std::option::Option::Some(
                                                    value,
                                                );
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "length") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Length as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minLength") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinLength as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxLength") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxLength as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "enumeration") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Enumeration as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __enumeration_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "whiteSpace") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <WhiteSpace as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __white_space_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "pattern") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Pattern as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __pattern_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assertion") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assertion as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assertion_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assert") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assert as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assert_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "base" {
                                            let visitor = __Visitor_Attribute_Base_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __base_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __attribute_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "SimpleContentRestriction",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(SimpleContentRestriction {
                        base: __base_value,
                        id: __id_value,
                        annotation: __annotation_value,
                        simple_type: __simple_type_value,
                        min_exclusive: __min_exclusive_value,
                        min_inclusive: __min_inclusive_value,
                        max_exclusive: __max_exclusive_value,
                        max_inclusive: __max_inclusive_value,
                        total_digits: __total_digits_value,
                        fraction_digits: __fraction_digits_value,
                        length: __length_value,
                        min_length: __min_length_value,
                        max_length: __max_length_value,
                        enumeration: __enumeration_value,
                        white_space: __white_space_value,
                        pattern: __pattern_value,
                        assertion: __assertion_value,
                        attribute: __attribute_value
                            .ok_or_else(|| {
                                "attribute is a required field of SimpleContentRestriction"
                                    .to_string()
                            })?,
                        assert: __assert_value,
                    })
                }
            }
        };
        /** SimpleCopntent
 * <extension
 *   base = QName
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?), assert*)
 * </extension>
 */
        #[yaserde(
            rename = "extension",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct SimpleContentExtension {
            #[yaserde(attribute)]
            pub base: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub attribute: AttributeType,
            #[yaserde(rename = "assert", prefix = "xs")]
            pub assert: Vec<Assert>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleContentExtension {
            #[inline]
            fn clone(&self) -> SimpleContentExtension {
                SimpleContentExtension {
                    base: ::core::clone::Clone::clone(&self.base),
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    assert: ::core::clone::Clone::clone(&self.assert),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleContentExtension {
            #[inline]
            fn default() -> SimpleContentExtension {
                SimpleContentExtension {
                    base: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    assert: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleContentExtension {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "SimpleContentExtension",
                    "base",
                    &self.base,
                    "id",
                    &self.id,
                    "annotation",
                    &self.annotation,
                    "attribute",
                    &self.attribute,
                    "assert",
                    &&self.assert,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleContentExtension {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleContentExtension {
            #[inline]
            fn eq(&self, other: &SimpleContentExtension) -> bool {
                self.base == other.base && self.id == other.id
                    && self.annotation == other.annotation
                    && self.attribute == other.attribute && self.assert == other.assert
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleContentExtension: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleContentExtension {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("extension"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "SimpleContentExtension",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __base_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __attribute_value: Option<AttributeType> = None;
                    #[allow(unused_mut)]
                    let mut __assert_value: ::std::vec::Vec<Assert> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Base_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Base_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "SimpleContentExtension",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assert") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assert as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assert_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "base" {
                                            let visitor = __Visitor_Attribute_Base_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __base_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __attribute_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "SimpleContentExtension",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(SimpleContentExtension {
                        base: __base_value,
                        id: __id_value,
                        annotation: __annotation_value,
                        attribute: __attribute_value
                            .ok_or_else(|| {
                                "attribute is a required field of SimpleContentExtension"
                                    .to_string()
                            })?,
                        assert: __assert_value,
                    })
                }
            }
        };
        /**
 * <openContent
 *   id = ID
 *   mode = (none | interleave | suffix) : interleave
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, any?)
 * </openContent>
 */
        #[yaserde(
            rename = "openContent",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct OpenContent {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub mode: Option<Mode>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "any")]
            pub any: Option<Any>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OpenContent {
            #[inline]
            fn clone(&self) -> OpenContent {
                OpenContent {
                    id: ::core::clone::Clone::clone(&self.id),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    any: ::core::clone::Clone::clone(&self.any),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for OpenContent {
            #[inline]
            fn default() -> OpenContent {
                OpenContent {
                    id: ::core::default::Default::default(),
                    mode: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    any: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OpenContent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "OpenContent",
                    "id",
                    &self.id,
                    "mode",
                    &self.mode,
                    "annotation",
                    &self.annotation,
                    "any",
                    &&self.any,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OpenContent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OpenContent {
            #[inline]
            fn eq(&self, other: &OpenContent) -> bool {
                self.id == other.id && self.mode == other.mode
                    && self.annotation == other.annotation && self.any == other.any
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_OpenContent: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for OpenContent {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("openContent"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "OpenContent",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __mode_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __any_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Mode_Mode;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Mode_Mode {
                        type Value = Mode;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Mode>", v, "</Mode>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "OpenContent",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("", "any") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Any as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "mode" {
                                            let visitor = __Visitor_Attribute_Mode_Mode {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __mode_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "OpenContent",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(OpenContent {
                        id: __id_value,
                        mode: __mode_value,
                        annotation: __annotation_value,
                        any: __any_value,
                    })
                }
            }
        };
        pub enum Mode {
            #[default]
            #[yaserde(rename = "none")]
            None,
            #[yaserde(rename = "interleave")]
            Interleave,
            #[yaserde(rename = "suffix")]
            Suffix,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Mode {
            #[inline]
            fn clone(&self) -> Mode {
                match self {
                    Mode::None => Mode::None,
                    Mode::Interleave => Mode::Interleave,
                    Mode::Suffix => Mode::Suffix,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Mode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Mode::None => "None",
                        Mode::Interleave => "Interleave",
                        Mode::Suffix => "Suffix",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Mode {
            #[inline]
            fn default() -> Mode {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Mode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Mode {
            #[inline]
            fn eq(&self, other: &Mode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Mode: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Mode {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("Mode"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "Mode",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "Mode",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::content",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "none" => {
                                        enum_value = ::std::option::Option::Some(Mode::None);
                                        break;
                                    }
                                    "interleave" => {
                                        enum_value = ::std::option::Option::Some(Mode::Interleave);
                                        break;
                                    }
                                    "suffix" => {
                                        enum_value = ::std::option::Option::Some(Mode::Suffix);
                                        break;
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "none" => {
                                            enum_value = ::std::option::Option::Some(Mode::None);
                                            break;
                                        }
                                        "interleave" => {
                                            enum_value = ::std::option::Option::Some(Mode::Interleave);
                                            break;
                                        }
                                        "suffix" => {
                                            enum_value = ::std::option::Option::Some(Mode::Suffix);
                                            break;
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "Mode",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::content",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(<Mode as ::std::default::Default>::default()),
                    )
                }
            }
        };
    }
    pub mod types {
        use yaserde::*;
        use crate::xsd::default_fn::*;
        use crate::xsd::{
            content::{SimpleContent, ComplexContent, OpenContent},
            annotation::Annotation, attribute::RefAttributeType,
            type_def::{
                Assert, Assertion, ComplexChildren, Enumeration, ExplicitTimezone,
                FractionDigits, Length, MaxExclusive, MaxInclusive, MaxLength,
                MinExclusive, MinInclusive, MinLength, Pattern, TotalDigits, WhiteSpace,
            },
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum ComplexTypeContent {
            #[default]
            None,
            #[yaserde(rename = "simpleContent", prefix = "xs")]
            SimpleContent(SimpleContent),
            #[yaserde(rename = "complexContent", prefix = "xs")]
            ComplexContent(ComplexContent),
            #[yaserde(rename = "openContent", prefix = "xs")]
            OpenContent(OpenContent),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexTypeContent {
            #[inline]
            fn clone(&self) -> ComplexTypeContent {
                match self {
                    ComplexTypeContent::None => ComplexTypeContent::None,
                    ComplexTypeContent::SimpleContent(__self_0) => {
                        ComplexTypeContent::SimpleContent(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ComplexTypeContent::ComplexContent(__self_0) => {
                        ComplexTypeContent::ComplexContent(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ComplexTypeContent::OpenContent(__self_0) => {
                        ComplexTypeContent::OpenContent(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexTypeContent {
            #[inline]
            fn default() -> ComplexTypeContent {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexTypeContent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ComplexTypeContent::None => {
                        ::core::fmt::Formatter::write_str(f, "None")
                    }
                    ComplexTypeContent::SimpleContent(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "SimpleContent",
                            &__self_0,
                        )
                    }
                    ComplexTypeContent::ComplexContent(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ComplexContent",
                            &__self_0,
                        )
                    }
                    ComplexTypeContent::OpenContent(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OpenContent",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexTypeContent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexTypeContent {
            #[inline]
            fn eq(&self, other: &ComplexTypeContent) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            ComplexTypeContent::SimpleContent(__self_0),
                            ComplexTypeContent::SimpleContent(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexTypeContent::ComplexContent(__self_0),
                            ComplexTypeContent::ComplexContent(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexTypeContent::OpenContent(__self_0),
                            ComplexTypeContent::OpenContent(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexTypeContent: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexTypeContent {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("ComplexTypeContent"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "ComplexTypeContent",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "ComplexTypeContent",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "None" => {
                                        enum_value = ::std::option::Option::Some(
                                            ComplexTypeContent::None,
                                        );
                                        break;
                                    }
                                    "simpleContent" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = SimpleContent;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "SimpleContent" + ">" + v
                                                    + "</" + "SimpleContent" + ">";
                                                let value: ::std::result::Result<
                                                    SimpleContent,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <SimpleContent as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexTypeContent::SimpleContent(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "complexContent" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = ComplexContent;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "ComplexContent" + ">" + v
                                                    + "</" + "ComplexContent" + ">";
                                                let value: ::std::result::Result<
                                                    ComplexContent,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <ComplexContent as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexTypeContent::ComplexContent(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "openContent" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = OpenContent;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "OpenContent" + ">" + v
                                                    + "</" + "OpenContent" + ">";
                                                let value: ::std::result::Result<
                                                    OpenContent,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <OpenContent as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexTypeContent::OpenContent(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "None" => {
                                            enum_value = ::std::option::Option::Some(
                                                ComplexTypeContent::None,
                                            );
                                            break;
                                        }
                                        "simpleContent" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = SimpleContent;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "SimpleContent" + ">" + v
                                                        + "</" + "SimpleContent" + ">";
                                                    let value: ::std::result::Result<
                                                        SimpleContent,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <SimpleContent as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexTypeContent::SimpleContent(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "complexContent" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = ComplexContent;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "ComplexContent" + ">" + v
                                                        + "</" + "ComplexContent" + ">";
                                                    let value: ::std::result::Result<
                                                        ComplexContent,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <ComplexContent as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexTypeContent::ComplexContent(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "openContent" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = OpenContent;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "OpenContent" + ">" + v
                                                        + "</" + "OpenContent" + ">";
                                                    let value: ::std::result::Result<
                                                        OpenContent,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <OpenContent as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexTypeContent::OpenContent(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "ComplexTypeContent",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <ComplexTypeContent as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        /**
 * <complexType
 *  abstract = boolean : false
 *  block = (#all | List of (extension | restriction))
 *  final = (#all | List of (extension | restriction))
 *  id = ID
 *  mixed = boolean
 *  name = NCName
 *  defaultAttributesApply = boolean : true
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, (simpleContent | complexContent | (openContent?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), assert*)))
 * </complexType>
 *
 * Content means simpleContent | complexContent | openContent are optional, and only one will apear
 * if simpleContent or complexContent, then you can't add other content (like gourp, attribute, etc)
 */
        #[yaserde(
            rename = "complexType",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct ComplexType {
            #[yaserde(attribute, rename = "abstract", default = "default_false")]
            pub abstract_v: bool,
            #[yaserde(attribute, rename = "block")]
            pub block: Option<String>,
            #[yaserde(attribute, rename = "final")]
            pub final_v: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub mixed: Option<bool>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(
                attribute,
                rename = "defaultAttributesApply",
                default = "default_true"
            )]
            pub default_attributes_apply: bool,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub content: ComplexTypeContent,
            #[yaserde(flatten)]
            pub complex_children: ComplexChildren,
            #[yaserde(flatten)]
            pub attribute: RefAttributeType,
            #[yaserde(rename = "assert", prefix = "xs")]
            pub assert: Vec<Assert>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexType {
            #[inline]
            fn clone(&self) -> ComplexType {
                ComplexType {
                    abstract_v: ::core::clone::Clone::clone(&self.abstract_v),
                    block: ::core::clone::Clone::clone(&self.block),
                    final_v: ::core::clone::Clone::clone(&self.final_v),
                    id: ::core::clone::Clone::clone(&self.id),
                    mixed: ::core::clone::Clone::clone(&self.mixed),
                    name: ::core::clone::Clone::clone(&self.name),
                    default_attributes_apply: ::core::clone::Clone::clone(
                        &self.default_attributes_apply,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    content: ::core::clone::Clone::clone(&self.content),
                    complex_children: ::core::clone::Clone::clone(
                        &self.complex_children,
                    ),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    assert: ::core::clone::Clone::clone(&self.assert),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexType {
            #[inline]
            fn default() -> ComplexType {
                ComplexType {
                    abstract_v: ::core::default::Default::default(),
                    block: ::core::default::Default::default(),
                    final_v: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    mixed: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    default_attributes_apply: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    content: ::core::default::Default::default(),
                    complex_children: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    assert: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "abstract_v",
                    "block",
                    "final_v",
                    "id",
                    "mixed",
                    "name",
                    "default_attributes_apply",
                    "annotation",
                    "content",
                    "complex_children",
                    "attribute",
                    "assert",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.abstract_v,
                    &self.block,
                    &self.final_v,
                    &self.id,
                    &self.mixed,
                    &self.name,
                    &self.default_attributes_apply,
                    &self.annotation,
                    &self.content,
                    &self.complex_children,
                    &self.attribute,
                    &&self.assert,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ComplexType",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexType {
            #[inline]
            fn eq(&self, other: &ComplexType) -> bool {
                self.abstract_v == other.abstract_v && self.block == other.block
                    && self.final_v == other.final_v && self.id == other.id
                    && self.mixed == other.mixed && self.name == other.name
                    && self.default_attributes_apply == other.default_attributes_apply
                    && self.annotation == other.annotation
                    && self.content == other.content
                    && self.complex_children == other.complex_children
                    && self.attribute == other.attribute && self.assert == other.assert
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexType: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexType {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("complexType"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "ComplexType",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __abstract_v_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __block_value = None;
                    #[allow(unused_mut)]
                    let mut __final_v_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __mixed_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __default_attributes_apply_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __content_value: Option<ComplexTypeContent> = None;
                    #[allow(unused_mut)]
                    let mut __complex_children_value: Option<ComplexChildren> = None;
                    #[allow(unused_mut)]
                    let mut __attribute_value: Option<RefAttributeType> = None;
                    #[allow(unused_mut)]
                    let mut __assert_value: ::std::vec::Vec<Assert> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Abstract_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Abstract_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Block_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Block_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Final_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Final_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Mixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Mixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_DefaultAttributesApply_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_DefaultAttributesApply_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "ComplexType",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assert") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assert as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assert_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "abstract" {
                                            let visitor = __Visitor_Attribute_Abstract_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __abstract_v_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "block" {
                                            let visitor = __Visitor_Attribute_Block_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __block_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "final" {
                                            let visitor = __Visitor_Attribute_Final_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __final_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "mixed" {
                                            let visitor = __Visitor_Attribute_Mixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __mixed_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "defaultAttributesApply" {
                                            let visitor = __Visitor_Attribute_DefaultAttributesApply_ {
                                            };
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __default_attributes_apply_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __content_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                        __complex_children_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                        __attribute_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "ComplexType",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(ComplexType {
                        abstract_v: __abstract_v_value
                            .unwrap_or_else(|| default_false()),
                        block: __block_value,
                        final_v: __final_v_value,
                        id: __id_value,
                        mixed: __mixed_value,
                        name: __name_value,
                        default_attributes_apply: __default_attributes_apply_value
                            .unwrap_or_else(|| default_true()),
                        annotation: __annotation_value,
                        content: __content_value
                            .ok_or_else(|| {
                                "content is a required field of ComplexType".to_string()
                            })?,
                        complex_children: __complex_children_value
                            .ok_or_else(|| {
                                "complex_children is a required field of ComplexType"
                                    .to_string()
                            })?,
                        attribute: __attribute_value
                            .ok_or_else(|| {
                                "attribute is a required field of ComplexType".to_string()
                            })?,
                        assert: __assert_value,
                    })
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum SimpleTypeComponenet {
            #[default]
            None,
            #[yaserde(rename = "restriction", prefix = "xs")]
            Restriction(SimpleTypeRestriction),
            #[yaserde(rename = "list", prefix = "xs")]
            List(List),
            #[yaserde(rename = "union", prefix = "xs")]
            Union(Union),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleTypeComponenet {
            #[inline]
            fn clone(&self) -> SimpleTypeComponenet {
                match self {
                    SimpleTypeComponenet::None => SimpleTypeComponenet::None,
                    SimpleTypeComponenet::Restriction(__self_0) => {
                        SimpleTypeComponenet::Restriction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SimpleTypeComponenet::List(__self_0) => {
                        SimpleTypeComponenet::List(::core::clone::Clone::clone(__self_0))
                    }
                    SimpleTypeComponenet::Union(__self_0) => {
                        SimpleTypeComponenet::Union(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleTypeComponenet {
            #[inline]
            fn default() -> SimpleTypeComponenet {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleTypeComponenet {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SimpleTypeComponenet::None => {
                        ::core::fmt::Formatter::write_str(f, "None")
                    }
                    SimpleTypeComponenet::Restriction(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Restriction",
                            &__self_0,
                        )
                    }
                    SimpleTypeComponenet::List(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "List",
                            &__self_0,
                        )
                    }
                    SimpleTypeComponenet::Union(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Union",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleTypeComponenet {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleTypeComponenet {
            #[inline]
            fn eq(&self, other: &SimpleTypeComponenet) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            SimpleTypeComponenet::Restriction(__self_0),
                            SimpleTypeComponenet::Restriction(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            SimpleTypeComponenet::List(__self_0),
                            SimpleTypeComponenet::List(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            SimpleTypeComponenet::Union(__self_0),
                            SimpleTypeComponenet::Union(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleTypeComponenet: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleTypeComponenet {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("SimpleTypeComponenet"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "SimpleTypeComponenet",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "SimpleTypeComponenet",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "None" => {
                                        enum_value = ::std::option::Option::Some(
                                            SimpleTypeComponenet::None,
                                        );
                                        break;
                                    }
                                    "restriction" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = SimpleTypeRestriction;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "SimpleTypeRestriction"
                                                    + ">" + v + "</" + "SimpleTypeRestriction" + ">";
                                                let value: ::std::result::Result<
                                                    SimpleTypeRestriction,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <SimpleTypeRestriction as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    SimpleTypeComponenet::Restriction(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "list" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = List;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "List" + ">" + v + "</"
                                                    + "List" + ">";
                                                let value: ::std::result::Result<
                                                    List,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <List as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    SimpleTypeComponenet::List(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "union" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Union;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Union" + ">" + v + "</"
                                                    + "Union" + ">";
                                                let value: ::std::result::Result<
                                                    Union,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Union as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    SimpleTypeComponenet::Union(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "None" => {
                                            enum_value = ::std::option::Option::Some(
                                                SimpleTypeComponenet::None,
                                            );
                                            break;
                                        }
                                        "restriction" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = SimpleTypeRestriction;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "SimpleTypeRestriction"
                                                        + ">" + v + "</" + "SimpleTypeRestriction" + ">";
                                                    let value: ::std::result::Result<
                                                        SimpleTypeRestriction,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <SimpleTypeRestriction as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        SimpleTypeComponenet::Restriction(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "list" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = List;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "List" + ">" + v + "</"
                                                        + "List" + ">";
                                                    let value: ::std::result::Result<
                                                        List,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <List as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        SimpleTypeComponenet::List(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "union" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Union;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Union" + ">" + v + "</"
                                                        + "Union" + ">";
                                                    let value: ::std::result::Result<
                                                        Union,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Union as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        SimpleTypeComponenet::Union(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "SimpleTypeComponenet",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <SimpleTypeComponenet as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        /**
 * <simpleType
 *  final = (#all | List of (list | union | restriction | extension))
 *  id = ID
 *  name = NCName
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, (restriction | list | union))
 * </simpleType>
 */
        #[yaserde(
            rename = "simpleType",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct SimpleType {
            #[yaserde(attribute, rename = "final")]
            pub final_v: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub restriction: SimpleTypeComponenet,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleType {
            #[inline]
            fn clone(&self) -> SimpleType {
                SimpleType {
                    final_v: ::core::clone::Clone::clone(&self.final_v),
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    restriction: ::core::clone::Clone::clone(&self.restriction),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleType {
            #[inline]
            fn default() -> SimpleType {
                SimpleType {
                    final_v: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    restriction: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "SimpleType",
                    "final_v",
                    &self.final_v,
                    "id",
                    &self.id,
                    "name",
                    &self.name,
                    "annotation",
                    &self.annotation,
                    "restriction",
                    &&self.restriction,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleType {
            #[inline]
            fn eq(&self, other: &SimpleType) -> bool {
                self.final_v == other.final_v && self.id == other.id
                    && self.name == other.name && self.annotation == other.annotation
                    && self.restriction == other.restriction
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleType: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleType {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("simpleType"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "SimpleType",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __final_v_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __restriction_value: Option<SimpleTypeComponenet> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Final_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Final_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "SimpleType",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "final" {
                                            let visitor = __Visitor_Attribute_Final_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __final_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __restriction_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "SimpleType",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(SimpleType {
                        final_v: __final_v_value,
                        id: __id_value,
                        name: __name_value,
                        annotation: __annotation_value,
                        restriction: __restriction_value
                            .ok_or_else(|| {
                                "restriction is a required field of SimpleType".to_string()
                            })?,
                    })
                }
            }
        };
        /** SimpleType
 * <restriction
 *   base = QName
 *   id = ID
 *   {any attributes with non-schema namespace . . .}>
 *   Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern | assertion | explicitTimezone | {any with namespace: ##other})*))
 * </restriction>
 */
        #[yaserde(
            rename = "restriction",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct SimpleTypeRestriction {
            #[yaserde(attribute)]
            pub base: Option<String>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            pub simple_type: Vec<SimpleType>,
            #[yaserde(rename = "minExclusive", prefix = "xs")]
            pub min_exclusive: Option<MinExclusive>,
            #[yaserde(rename = "minInclusive", prefix = "xs")]
            pub min_inclusive: Option<MinInclusive>,
            #[yaserde(rename = "maxExclusive", prefix = "xs")]
            pub max_exclusive: Option<MaxExclusive>,
            #[yaserde(rename = "maxInclusive", prefix = "xs")]
            pub max_inclusive: Option<MaxInclusive>,
            #[yaserde(rename = "totalDigits", prefix = "xs")]
            pub total_digits: Option<TotalDigits>,
            #[yaserde(rename = "fractionDigits", prefix = "xs")]
            pub fraction_digits: Option<FractionDigits>,
            #[yaserde(rename = "length", prefix = "xs")]
            pub length: Option<Length>,
            #[yaserde(rename = "minLength", prefix = "xs")]
            pub min_length: Option<MinLength>,
            #[yaserde(rename = "maxLength", prefix = "xs")]
            pub max_length: Option<MaxLength>,
            #[yaserde(rename = "enumeration", prefix = "xs")]
            pub enumeration: Vec<Enumeration>,
            #[yaserde(rename = "whiteSpace", prefix = "xs")]
            pub white_space: Vec<WhiteSpace>,
            #[yaserde(rename = "pattern", prefix = "xs")]
            pub pattern: Vec<Pattern>,
            #[yaserde(rename = "assertion", prefix = "xs")]
            pub assertion: Vec<Assertion>,
            #[yaserde(rename = "explicitTimezone", prefix = "xs")]
            pub explicit_timezone: Vec<ExplicitTimezone>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SimpleTypeRestriction {
            #[inline]
            fn clone(&self) -> SimpleTypeRestriction {
                SimpleTypeRestriction {
                    base: ::core::clone::Clone::clone(&self.base),
                    id: ::core::clone::Clone::clone(&self.id),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    simple_type: ::core::clone::Clone::clone(&self.simple_type),
                    min_exclusive: ::core::clone::Clone::clone(&self.min_exclusive),
                    min_inclusive: ::core::clone::Clone::clone(&self.min_inclusive),
                    max_exclusive: ::core::clone::Clone::clone(&self.max_exclusive),
                    max_inclusive: ::core::clone::Clone::clone(&self.max_inclusive),
                    total_digits: ::core::clone::Clone::clone(&self.total_digits),
                    fraction_digits: ::core::clone::Clone::clone(&self.fraction_digits),
                    length: ::core::clone::Clone::clone(&self.length),
                    min_length: ::core::clone::Clone::clone(&self.min_length),
                    max_length: ::core::clone::Clone::clone(&self.max_length),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    white_space: ::core::clone::Clone::clone(&self.white_space),
                    pattern: ::core::clone::Clone::clone(&self.pattern),
                    assertion: ::core::clone::Clone::clone(&self.assertion),
                    explicit_timezone: ::core::clone::Clone::clone(
                        &self.explicit_timezone,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SimpleTypeRestriction {
            #[inline]
            fn default() -> SimpleTypeRestriction {
                SimpleTypeRestriction {
                    base: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    simple_type: ::core::default::Default::default(),
                    min_exclusive: ::core::default::Default::default(),
                    min_inclusive: ::core::default::Default::default(),
                    max_exclusive: ::core::default::Default::default(),
                    max_inclusive: ::core::default::Default::default(),
                    total_digits: ::core::default::Default::default(),
                    fraction_digits: ::core::default::Default::default(),
                    length: ::core::default::Default::default(),
                    min_length: ::core::default::Default::default(),
                    max_length: ::core::default::Default::default(),
                    enumeration: ::core::default::Default::default(),
                    white_space: ::core::default::Default::default(),
                    pattern: ::core::default::Default::default(),
                    assertion: ::core::default::Default::default(),
                    explicit_timezone: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SimpleTypeRestriction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "id",
                    "annotation",
                    "simple_type",
                    "min_exclusive",
                    "min_inclusive",
                    "max_exclusive",
                    "max_inclusive",
                    "total_digits",
                    "fraction_digits",
                    "length",
                    "min_length",
                    "max_length",
                    "enumeration",
                    "white_space",
                    "pattern",
                    "assertion",
                    "explicit_timezone",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.id,
                    &self.annotation,
                    &self.simple_type,
                    &self.min_exclusive,
                    &self.min_inclusive,
                    &self.max_exclusive,
                    &self.max_inclusive,
                    &self.total_digits,
                    &self.fraction_digits,
                    &self.length,
                    &self.min_length,
                    &self.max_length,
                    &self.enumeration,
                    &self.white_space,
                    &self.pattern,
                    &self.assertion,
                    &&self.explicit_timezone,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SimpleTypeRestriction",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SimpleTypeRestriction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SimpleTypeRestriction {
            #[inline]
            fn eq(&self, other: &SimpleTypeRestriction) -> bool {
                self.base == other.base && self.id == other.id
                    && self.annotation == other.annotation
                    && self.simple_type == other.simple_type
                    && self.min_exclusive == other.min_exclusive
                    && self.min_inclusive == other.min_inclusive
                    && self.max_exclusive == other.max_exclusive
                    && self.max_inclusive == other.max_inclusive
                    && self.total_digits == other.total_digits
                    && self.fraction_digits == other.fraction_digits
                    && self.length == other.length && self.min_length == other.min_length
                    && self.max_length == other.max_length
                    && self.enumeration == other.enumeration
                    && self.white_space == other.white_space
                    && self.pattern == other.pattern && self.assertion == other.assertion
                    && self.explicit_timezone == other.explicit_timezone
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_SimpleTypeRestriction: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for SimpleTypeRestriction {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("restriction"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "SimpleTypeRestriction",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __base_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __simple_type_value: ::std::vec::Vec<SimpleType> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __min_exclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __min_inclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __max_exclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __max_inclusive_value = None;
                    #[allow(unused_mut)]
                    let mut __total_digits_value = None;
                    #[allow(unused_mut)]
                    let mut __fraction_digits_value = None;
                    #[allow(unused_mut)]
                    let mut __length_value = None;
                    #[allow(unused_mut)]
                    let mut __min_length_value = None;
                    #[allow(unused_mut)]
                    let mut __max_length_value = None;
                    #[allow(unused_mut)]
                    let mut __enumeration_value: ::std::vec::Vec<Enumeration> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __white_space_value: ::std::vec::Vec<WhiteSpace> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __pattern_value: ::std::vec::Vec<Pattern> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __assertion_value: ::std::vec::Vec<Assertion> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __explicit_timezone_value: ::std::vec::Vec<
                        ExplicitTimezone,
                    > = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Base_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Base_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "SimpleTypeRestriction",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_type_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minExclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinExclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_exclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minInclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinInclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_inclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxExclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxExclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_exclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxInclusive") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxInclusive as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_inclusive_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "totalDigits") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <TotalDigits as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __total_digits_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "fractionDigits") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <FractionDigits as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __fraction_digits_value = ::std::option::Option::Some(
                                                    value,
                                                );
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "length") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Length as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "minLength") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MinLength as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __min_length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "maxLength") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <MaxLength as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __max_length_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "enumeration") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Enumeration as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __enumeration_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "whiteSpace") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <WhiteSpace as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __white_space_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "pattern") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Pattern as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __pattern_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "assertion") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Assertion as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __assertion_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        (
                                            "http://www.w3.org/2001/XMLSchema",
                                            "explicitTimezone",
                                        ) => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <ExplicitTimezone as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __explicit_timezone_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "base" {
                                            let visitor = __Visitor_Attribute_Base_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __base_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "SimpleTypeRestriction",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(SimpleTypeRestriction {
                        base: __base_value,
                        id: __id_value,
                        annotation: __annotation_value,
                        simple_type: __simple_type_value,
                        min_exclusive: __min_exclusive_value,
                        min_inclusive: __min_inclusive_value,
                        max_exclusive: __max_exclusive_value,
                        max_inclusive: __max_inclusive_value,
                        total_digits: __total_digits_value,
                        fraction_digits: __fraction_digits_value,
                        length: __length_value,
                        min_length: __min_length_value,
                        max_length: __max_length_value,
                        enumeration: __enumeration_value,
                        white_space: __white_space_value,
                        pattern: __pattern_value,
                        assertion: __assertion_value,
                        explicit_timezone: __explicit_timezone_value,
                    })
                }
            }
        };
        /**
 * <list
 *  id = ID
 *  itemType = QName
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, simpleType?)
 *</list>
 */
        #[yaserde(
            rename = "list",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct List {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "itemType")]
            pub item_type: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            pub simple_type: Vec<SimpleType>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for List {
            #[inline]
            fn clone(&self) -> List {
                List {
                    id: ::core::clone::Clone::clone(&self.id),
                    item_type: ::core::clone::Clone::clone(&self.item_type),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    simple_type: ::core::clone::Clone::clone(&self.simple_type),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for List {
            #[inline]
            fn default() -> List {
                List {
                    id: ::core::default::Default::default(),
                    item_type: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    simple_type: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for List {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "List",
                    "id",
                    &self.id,
                    "item_type",
                    &self.item_type,
                    "annotation",
                    &self.annotation,
                    "simple_type",
                    &&self.simple_type,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for List {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for List {
            #[inline]
            fn eq(&self, other: &List) -> bool {
                self.id == other.id && self.item_type == other.item_type
                    && self.annotation == other.annotation
                    && self.simple_type == other.simple_type
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_List: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for List {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("list"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "List",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __item_type_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __simple_type_value: ::std::vec::Vec<SimpleType> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_ItemType_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_ItemType_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "List",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_type_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "itemType" {
                                            let visitor = __Visitor_Attribute_ItemType_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __item_type_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "List",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(List {
                        id: __id_value,
                        item_type: __item_type_value,
                        annotation: __annotation_value,
                        simple_type: __simple_type_value,
                    })
                }
            }
        };
        /**
 * <union
 *  id = ID
 *  memberTypes = List of QName
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, simpleType*)
 *</union>
 */
        #[yaserde(
            rename = "union",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Union {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "memberTypes")]
            pub member_types: Vec<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "simpleType")]
            pub simple_types: Vec<SimpleType>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Union {
            #[inline]
            fn clone(&self) -> Union {
                Union {
                    id: ::core::clone::Clone::clone(&self.id),
                    member_types: ::core::clone::Clone::clone(&self.member_types),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    simple_types: ::core::clone::Clone::clone(&self.simple_types),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Union {
            #[inline]
            fn default() -> Union {
                Union {
                    id: ::core::default::Default::default(),
                    member_types: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    simple_types: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Union {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Union",
                    "id",
                    &self.id,
                    "member_types",
                    &self.member_types,
                    "annotation",
                    &self.annotation,
                    "simple_types",
                    &&self.simple_types,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Union {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Union {
            #[inline]
            fn eq(&self, other: &Union) -> bool {
                self.id == other.id && self.member_types == other.member_types
                    && self.annotation == other.annotation
                    && self.simple_types == other.simple_types
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Union: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Union {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("union"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Union",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __member_types_value: ::std::vec::Vec<
                        ::std::string::String,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __simple_types_value: ::std::vec::Vec<SimpleType> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MemberTypes_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MemberTypes_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Union",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::types",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_types_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "memberTypes" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_MemberTypes_ {
                                                };
                                                let value = visitor.visit_str(value)?;
                                                __member_types_value.push(value);
                                            }
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Union",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::types",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Union {
                        id: __id_value,
                        member_types: __member_types_value,
                        annotation: __annotation_value,
                        simple_types: __simple_types_value,
                    })
                }
            }
        };
    }
    pub mod element {
        use yaserde::*;
        use crate::xsd::default_fn::*;
        use crate::xsd::{
            type_def::Alternative, type_def::Unique, type_def::Key, type_def::KeyRef,
            type_def::Form, annotation::Annotation, types::ComplexType, types::SimpleType,
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum TypeComponent {
            #[default]
            None,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            SimpleType(SimpleType),
            #[yaserde(rename = "complexType", prefix = "xs")]
            ComplexType(ComplexType),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TypeComponent {
            #[inline]
            fn clone(&self) -> TypeComponent {
                match self {
                    TypeComponent::None => TypeComponent::None,
                    TypeComponent::SimpleType(__self_0) => {
                        TypeComponent::SimpleType(::core::clone::Clone::clone(__self_0))
                    }
                    TypeComponent::ComplexType(__self_0) => {
                        TypeComponent::ComplexType(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TypeComponent {
            #[inline]
            fn default() -> TypeComponent {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TypeComponent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TypeComponent::None => ::core::fmt::Formatter::write_str(f, "None"),
                    TypeComponent::SimpleType(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "SimpleType",
                            &__self_0,
                        )
                    }
                    TypeComponent::ComplexType(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ComplexType",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TypeComponent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TypeComponent {
            #[inline]
            fn eq(&self, other: &TypeComponent) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            TypeComponent::SimpleType(__self_0),
                            TypeComponent::SimpleType(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            TypeComponent::ComplexType(__self_0),
                            TypeComponent::ComplexType(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_TypeComponent: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for TypeComponent {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("TypeComponent"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "TypeComponent",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::element",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "TypeComponent",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::element",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "None" => {
                                        enum_value = ::std::option::Option::Some(
                                            TypeComponent::None,
                                        );
                                        break;
                                    }
                                    "simpleType" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = SimpleType;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "SimpleType" + ">" + v
                                                    + "</" + "SimpleType" + ">";
                                                let value: ::std::result::Result<
                                                    SimpleType,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    TypeComponent::SimpleType(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "complexType" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = ComplexType;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "ComplexType" + ">" + v
                                                    + "</" + "ComplexType" + ">";
                                                let value: ::std::result::Result<
                                                    ComplexType,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <ComplexType as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    TypeComponent::ComplexType(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "None" => {
                                            enum_value = ::std::option::Option::Some(
                                                TypeComponent::None,
                                            );
                                            break;
                                        }
                                        "simpleType" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = SimpleType;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "SimpleType" + ">" + v
                                                        + "</" + "SimpleType" + ">";
                                                    let value: ::std::result::Result<
                                                        SimpleType,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        TypeComponent::SimpleType(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "complexType" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = ComplexType;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "ComplexType" + ">" + v
                                                        + "</" + "ComplexType" + ">";
                                                    let value: ::std::result::Result<
                                                        ComplexType,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <ComplexType as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        TypeComponent::ComplexType(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "TypeComponent",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::element",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <TypeComponent as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        /**
 * <element
 *  abstract = boolean : false
 *  block = (#all | List of (extension | restriction | substitution))
 *  default = string
 *  final = (#all | List of (extension | restriction))
 *  fixed = string
 *  form = (qualified | unqualified)
 *  id = ID
 *  maxOccurs = (nonNegativeInteger | unbounded)  : 1
 *  minOccurs = nonNegativeInteger : 1
 *  name = NCName
 *  nillable = boolean : false
 *  ref = QName
 *  substitutionGroup = List of QName
 *  targetNamespace = anyURI
 *  type = QName
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?, ((simpleType | complexType)?, alternative*, (unique | key | keyref)*))
 * </element>
 */
        #[yaserde(
            rename = "element",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Element {
            #[yaserde(attribute, default = "default_false")]
            pub abstract_v: bool,
            #[yaserde(attribute, rename = "block")]
            pub block: Option<String>,
            #[yaserde(attribute)]
            pub default: Option<String>,
            #[yaserde(attribute, rename = "final")]
            pub final_v: Option<String>,
            #[yaserde(attribute)]
            pub fixed: Option<String>,
            #[yaserde(attribute)]
            pub form: Option<Form>,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs", default = "default_u32_1")]
            pub max_occurs: u32,
            #[yaserde(attribute, rename = "minOccurs", default = "default_u32_1")]
            pub min_occurs: u32,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute, default = "default_false")]
            pub nillable: bool,
            #[yaserde(attribute, rename = "ref")]
            pub ref_v: Option<String>,
            #[yaserde(attribute, rename = "substitutionGroup")]
            pub substitution_group: Vec<String>,
            #[yaserde(attribute, rename = "targetNamespace")]
            pub target_namespace: Option<String>,
            #[yaserde(attribute, rename = "type")]
            pub type_v: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub type_component: TypeComponent,
            #[yaserde(rename = "alternative", prefix = "xs")]
            pub alternatives: Vec<Alternative>,
            #[yaserde(rename = "unique")]
            pub unique: Vec<Unique>,
            #[yaserde(rename = "key")]
            pub key: Vec<Key>,
            #[yaserde(rename = "keyref")]
            pub keyref: Vec<KeyRef>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Element {
            #[inline]
            fn clone(&self) -> Element {
                Element {
                    abstract_v: ::core::clone::Clone::clone(&self.abstract_v),
                    block: ::core::clone::Clone::clone(&self.block),
                    default: ::core::clone::Clone::clone(&self.default),
                    final_v: ::core::clone::Clone::clone(&self.final_v),
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    form: ::core::clone::Clone::clone(&self.form),
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    name: ::core::clone::Clone::clone(&self.name),
                    nillable: ::core::clone::Clone::clone(&self.nillable),
                    ref_v: ::core::clone::Clone::clone(&self.ref_v),
                    substitution_group: ::core::clone::Clone::clone(
                        &self.substitution_group,
                    ),
                    target_namespace: ::core::clone::Clone::clone(
                        &self.target_namespace,
                    ),
                    type_v: ::core::clone::Clone::clone(&self.type_v),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    type_component: ::core::clone::Clone::clone(&self.type_component),
                    alternatives: ::core::clone::Clone::clone(&self.alternatives),
                    unique: ::core::clone::Clone::clone(&self.unique),
                    key: ::core::clone::Clone::clone(&self.key),
                    keyref: ::core::clone::Clone::clone(&self.keyref),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Element {
            #[inline]
            fn default() -> Element {
                Element {
                    abstract_v: ::core::default::Default::default(),
                    block: ::core::default::Default::default(),
                    default: ::core::default::Default::default(),
                    final_v: ::core::default::Default::default(),
                    fixed: ::core::default::Default::default(),
                    form: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    nillable: ::core::default::Default::default(),
                    ref_v: ::core::default::Default::default(),
                    substitution_group: ::core::default::Default::default(),
                    target_namespace: ::core::default::Default::default(),
                    type_v: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    type_component: ::core::default::Default::default(),
                    alternatives: ::core::default::Default::default(),
                    unique: ::core::default::Default::default(),
                    key: ::core::default::Default::default(),
                    keyref: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Element {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "abstract_v",
                    "block",
                    "default",
                    "final_v",
                    "fixed",
                    "form",
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "name",
                    "nillable",
                    "ref_v",
                    "substitution_group",
                    "target_namespace",
                    "type_v",
                    "annotation",
                    "type_component",
                    "alternatives",
                    "unique",
                    "key",
                    "keyref",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.abstract_v,
                    &self.block,
                    &self.default,
                    &self.final_v,
                    &self.fixed,
                    &self.form,
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.name,
                    &self.nillable,
                    &self.ref_v,
                    &self.substitution_group,
                    &self.target_namespace,
                    &self.type_v,
                    &self.annotation,
                    &self.type_component,
                    &self.alternatives,
                    &self.unique,
                    &self.key,
                    &&self.keyref,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Element",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Element {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Element {
            #[inline]
            fn eq(&self, other: &Element) -> bool {
                self.abstract_v == other.abstract_v && self.block == other.block
                    && self.default == other.default && self.final_v == other.final_v
                    && self.fixed == other.fixed && self.form == other.form
                    && self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs && self.name == other.name
                    && self.nillable == other.nillable && self.ref_v == other.ref_v
                    && self.substitution_group == other.substitution_group
                    && self.target_namespace == other.target_namespace
                    && self.type_v == other.type_v && self.annotation == other.annotation
                    && self.type_component == other.type_component
                    && self.alternatives == other.alternatives
                    && self.unique == other.unique && self.key == other.key
                    && self.keyref == other.keyref
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Element: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Element {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("element"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Element",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::element",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __abstract_v_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __block_value = None;
                    #[allow(unused_mut)]
                    let mut __default_value = None;
                    #[allow(unused_mut)]
                    let mut __final_v_value = None;
                    #[allow(unused_mut)]
                    let mut __fixed_value = None;
                    #[allow(unused_mut)]
                    let mut __form_value = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __nillable_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __ref_v_value = None;
                    #[allow(unused_mut)]
                    let mut __substitution_group_value: ::std::vec::Vec<
                        ::std::string::String,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __target_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __type_v_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __type_component_value: Option<TypeComponent> = None;
                    #[allow(unused_mut)]
                    let mut __alternatives_value: ::std::vec::Vec<Alternative> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __unique_value: ::std::vec::Vec<Unique> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __key_value: ::std::vec::Vec<Key> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __keyref_value: ::std::vec::Vec<KeyRef> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_AbstractV_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_AbstractV_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Block_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Block_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Default_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Default_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Final_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Final_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Form_Form;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Form_Form {
                        type Value = Form;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Form>", v, "</Form>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Nillable_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Nillable_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Ref_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Ref_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_SubstitutionGroup_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_SubstitutionGroup_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_TargetNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_TargetNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Type_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Type_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Element",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::element",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "alternative") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Alternative as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __alternatives_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("", "unique") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Unique as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __unique_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("", "key") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Key as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __key_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("", "keyref") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <KeyRef as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __keyref_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "abstract_v" {
                                            let visitor = __Visitor_Attribute_AbstractV_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __abstract_v_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "block" {
                                            let visitor = __Visitor_Attribute_Block_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __block_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "default" {
                                            let visitor = __Visitor_Attribute_Default_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __default_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "final" {
                                            let visitor = __Visitor_Attribute_Final_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __final_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __fixed_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "form" {
                                            let visitor = __Visitor_Attribute_Form_Form {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __form_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __max_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "nillable" {
                                            let visitor = __Visitor_Attribute_Nillable_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __nillable_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "ref" {
                                            let visitor = __Visitor_Attribute_Ref_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __ref_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "substitutionGroup" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_SubstitutionGroup_ {
                                                };
                                                let value = visitor.visit_str(value)?;
                                                __substitution_group_value.push(value);
                                            }
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "targetNamespace" {
                                            let visitor = __Visitor_Attribute_TargetNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __target_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "type" {
                                            let visitor = __Visitor_Attribute_Type_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __type_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __type_component_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Element",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::element",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Element {
                        abstract_v: __abstract_v_value
                            .unwrap_or_else(|| default_false()),
                        block: __block_value,
                        default: __default_value,
                        final_v: __final_v_value,
                        fixed: __fixed_value,
                        form: __form_value,
                        id: __id_value,
                        max_occurs: __max_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        min_occurs: __min_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        name: __name_value,
                        nillable: __nillable_value.unwrap_or_else(|| default_false()),
                        ref_v: __ref_v_value,
                        substitution_group: __substitution_group_value,
                        target_namespace: __target_namespace_value,
                        type_v: __type_v_value,
                        annotation: __annotation_value,
                        type_component: __type_component_value
                            .ok_or_else(|| {
                                "type_component is a required field of Element".to_string()
                            })?,
                        alternatives: __alternatives_value,
                        unique: __unique_value,
                        key: __key_value,
                        keyref: __keyref_value,
                    })
                }
            }
        };
    }
    pub mod group {
        use yaserde::*;
        use crate::xsd::{
            sequence::{All, Choice, Sequence},
            annotation::Annotation,
        };
        /**
 * <group
 *   id = ID
 *   maxOccurs = (nonNegativeInteger | unbounded)  : 1
 *   minOccurs = nonNegativeInteger : 1
 *   name = NCName
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (all | choice | sequence)?)
 * </group>
 */
        #[yaserde(
            rename = "group",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Group {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs")]
            pub max_occurs: Option<u32>,
            #[yaserde(attribute, rename = "minOccurs")]
            pub min_occurs: Option<u32>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute, rename = "ref")]
            pub ref_v: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub componenet: GroupComponenet,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Group {
            #[inline]
            fn clone(&self) -> Group {
                Group {
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    name: ::core::clone::Clone::clone(&self.name),
                    ref_v: ::core::clone::Clone::clone(&self.ref_v),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    componenet: ::core::clone::Clone::clone(&self.componenet),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Group {
            #[inline]
            fn default() -> Group {
                Group {
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    ref_v: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    componenet: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Group {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "name",
                    "ref_v",
                    "annotation",
                    "componenet",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.name,
                    &self.ref_v,
                    &self.annotation,
                    &&self.componenet,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Group",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Group {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Group {
            #[inline]
            fn eq(&self, other: &Group) -> bool {
                self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs && self.name == other.name
                    && self.ref_v == other.ref_v && self.annotation == other.annotation
                    && self.componenet == other.componenet
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Group: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Group {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("group"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Group",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::group",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __ref_v_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __componenet_value: Option<GroupComponenet> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Ref_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Ref_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Group",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::group",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __max_occurs_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "ref" {
                                            let visitor = __Visitor_Attribute_Ref_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __ref_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __componenet_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Group",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::group",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Group {
                        id: __id_value,
                        max_occurs: __max_occurs_value,
                        min_occurs: __min_occurs_value,
                        name: __name_value,
                        ref_v: __ref_v_value,
                        annotation: __annotation_value,
                        componenet: __componenet_value
                            .ok_or_else(|| {
                                "componenet is a required field of Group".to_string()
                            })?,
                    })
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum GroupComponenet {
            #[default]
            None,
            #[yaserde(rename = "All", prefix = "xs")]
            All(All),
            #[yaserde(rename = "Choice", prefix = "xs")]
            Choice(Choice),
            #[yaserde(rename = "Sequence", prefix = "xs")]
            Sequence(Sequence),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GroupComponenet {
            #[inline]
            fn clone(&self) -> GroupComponenet {
                match self {
                    GroupComponenet::None => GroupComponenet::None,
                    GroupComponenet::All(__self_0) => {
                        GroupComponenet::All(::core::clone::Clone::clone(__self_0))
                    }
                    GroupComponenet::Choice(__self_0) => {
                        GroupComponenet::Choice(::core::clone::Clone::clone(__self_0))
                    }
                    GroupComponenet::Sequence(__self_0) => {
                        GroupComponenet::Sequence(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for GroupComponenet {
            #[inline]
            fn default() -> GroupComponenet {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GroupComponenet {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    GroupComponenet::None => ::core::fmt::Formatter::write_str(f, "None"),
                    GroupComponenet::All(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "All",
                            &__self_0,
                        )
                    }
                    GroupComponenet::Choice(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Choice",
                            &__self_0,
                        )
                    }
                    GroupComponenet::Sequence(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sequence",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GroupComponenet {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GroupComponenet {
            #[inline]
            fn eq(&self, other: &GroupComponenet) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            GroupComponenet::All(__self_0),
                            GroupComponenet::All(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            GroupComponenet::Choice(__self_0),
                            GroupComponenet::Choice(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            GroupComponenet::Sequence(__self_0),
                            GroupComponenet::Sequence(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_GroupComponenet: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for GroupComponenet {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("GroupComponenet"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "GroupComponenet",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::group",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "GroupComponenet",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::group",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "None" => {
                                        enum_value = ::std::option::Option::Some(
                                            GroupComponenet::None,
                                        );
                                        break;
                                    }
                                    "All" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = All;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "All" + ">" + v + "</"
                                                    + "All" + ">";
                                                let value: ::std::result::Result<
                                                    All,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <All as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    GroupComponenet::All(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "Choice" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Choice;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Choice" + ">" + v + "</"
                                                    + "Choice" + ">";
                                                let value: ::std::result::Result<
                                                    Choice,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Choice as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    GroupComponenet::Choice(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "Sequence" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Sequence;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Sequence" + ">" + v + "</"
                                                    + "Sequence" + ">";
                                                let value: ::std::result::Result<
                                                    Sequence,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    GroupComponenet::Sequence(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "None" => {
                                            enum_value = ::std::option::Option::Some(
                                                GroupComponenet::None,
                                            );
                                            break;
                                        }
                                        "All" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = All;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "All" + ">" + v + "</"
                                                        + "All" + ">";
                                                    let value: ::std::result::Result<
                                                        All,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <All as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        GroupComponenet::All(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "Choice" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Choice;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Choice" + ">" + v + "</"
                                                        + "Choice" + ">";
                                                    let value: ::std::result::Result<
                                                        Choice,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Choice as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        GroupComponenet::Choice(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "Sequence" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Sequence;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Sequence" + ">" + v + "</"
                                                        + "Sequence" + ">";
                                                    let value: ::std::result::Result<
                                                        Sequence,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        GroupComponenet::Sequence(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "GroupComponenet",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::group",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <GroupComponenet as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
    }
    pub mod import {
        use yaserde::*;
        use crate::xsd::annotation::Annotation;
        /**
 * <import
 *  id = ID
 *  namespace = anyURI
 *  schemaLocation = anyURI
 *  {any attributes with non-schema namespace . . .}>
 *    Content: (annotation?)
 * </import>
 */
        #[yaserde(
            root = "schema"
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema",
        )]
        pub struct Import {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub namespace: Option<String>,
            #[yaserde(rename = "schemaLocation", attribute)]
            pub schema_location: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotations: Vec<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Import {
            #[inline]
            fn clone(&self) -> Import {
                Import {
                    id: ::core::clone::Clone::clone(&self.id),
                    namespace: ::core::clone::Clone::clone(&self.namespace),
                    schema_location: ::core::clone::Clone::clone(&self.schema_location),
                    annotations: ::core::clone::Clone::clone(&self.annotations),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Import {
            #[inline]
            fn default() -> Import {
                Import {
                    id: ::core::default::Default::default(),
                    namespace: ::core::default::Default::default(),
                    schema_location: ::core::default::Default::default(),
                    annotations: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Import {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Import",
                    "id",
                    &self.id,
                    "namespace",
                    &self.namespace,
                    "schema_location",
                    &self.schema_location,
                    "annotations",
                    &&self.annotations,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Import {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Import {
            #[inline]
            fn eq(&self, other: &Import) -> bool {
                self.id == other.id && self.namespace == other.namespace
                    && self.schema_location == other.schema_location
                    && self.annotations == other.annotations
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Import: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Import {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("Import"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Import",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::import",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __schema_location_value = None;
                    #[allow(unused_mut)]
                    let mut __annotations_value: ::std::vec::Vec<Annotation> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Namespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Namespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_SchemaLocation_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_SchemaLocation_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Import",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::import",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotations_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "namespace" {
                                            let visitor = __Visitor_Attribute_Namespace_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __namespace_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "schemaLocation" {
                                            let visitor = __Visitor_Attribute_SchemaLocation_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __schema_location_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Import",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::import",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Import {
                        id: __id_value,
                        namespace: __namespace_value,
                        schema_location: __schema_location_value,
                        annotations: __annotations_value,
                    })
                }
            }
        };
    }
    pub mod max_occurences {
        use std::io::Read;
        use xml::reader::XmlEvent;
        use yaserde::YaDeserialize;
        pub enum MaxOccurences {
            Unbounded,
            Number { value: u32 },
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MaxOccurences {
            #[inline]
            fn clone(&self) -> MaxOccurences {
                match self {
                    MaxOccurences::Unbounded => MaxOccurences::Unbounded,
                    MaxOccurences::Number { value: __self_0 } => {
                        MaxOccurences::Number {
                            value: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MaxOccurences {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MaxOccurences::Unbounded => {
                        ::core::fmt::Formatter::write_str(f, "Unbounded")
                    }
                    MaxOccurences::Number { value: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Number",
                            "value",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MaxOccurences {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MaxOccurences {
            #[inline]
            fn eq(&self, other: &MaxOccurences) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            MaxOccurences::Number { value: __self_0 },
                            MaxOccurences::Number { value: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        impl Default for MaxOccurences {
            fn default() -> Self {
                MaxOccurences::Number { value: 1 }
            }
        }
        impl YaDeserialize for MaxOccurences {
            fn deserialize<R: Read>(
                reader: &mut yaserde::de::Deserializer<R>,
            ) -> Result<Self, String> {
                if let XmlEvent::StartElement { name, .. } = reader.peek()? {
                    if name.local_name != "MaxOccurences" {
                        return Err("Unable to parse Max Occurences field".to_string());
                    }
                    let _start_event = reader.next_event();
                    let content = reader.next_event()?;
                    match content {
                        XmlEvent::Characters(value) => {
                            if value == "unbounded" {
                                Ok(MaxOccurences::Unbounded)
                            } else {
                                let number = value
                                    .parse::<u32>()
                                    .map_err(|e| e.to_string())?;
                                Ok(MaxOccurences::Number {
                                    value: number,
                                })
                            }
                        }
                        _ => Err("bad content for Max Occurences field".to_string()),
                    }
                } else {
                    Err("Missing start event for Max Occurences field".to_string())
                }
            }
        }
    }
    pub mod schema {
        use yaserde::*;
        use crate::xsd::{attribute, types, element, group, import, type_def::Form};
        #[yaserde(
            root = "schema"
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema",
        )]
        pub struct Schema {
            #[yaserde(attribute)]
            pub xmlns: Option<String>,
            #[yaserde(rename = "targetNamespace", attribute)]
            pub target_namespace: Option<String>,
            #[yaserde(rename = "elementFormDefault", attribute)]
            pub element_form_default: Option<Form>,
            #[yaserde(rename = "attributeFormDefault", attribute)]
            pub attribute_form_default: Option<Form>,
            #[yaserde(rename = "import", prefix = "xs")]
            pub imports: Vec<import::Import>,
            #[yaserde(rename = "element", prefix = "xs")]
            pub elements: Vec<element::Element>,
            #[yaserde(rename = "simpleType", prefix = "xs")]
            pub simple_type: Vec<types::SimpleType>,
            #[yaserde(rename = "complexType", prefix = "xs")]
            pub complex_type: Vec<types::ComplexType>,
            #[yaserde(rename = "attribute", prefix = "xs")]
            pub attribute: Vec<attribute::Attribute>,
            #[yaserde(rename = "attributeGroup", prefix = "xs")]
            pub attribute_group: Vec<attribute::AttributeGroup>,
            #[yaserde(rename = "group", prefix = "xs")]
            pub group: Vec<group::Group>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Schema {
            #[inline]
            fn clone(&self) -> Schema {
                Schema {
                    xmlns: ::core::clone::Clone::clone(&self.xmlns),
                    target_namespace: ::core::clone::Clone::clone(
                        &self.target_namespace,
                    ),
                    element_form_default: ::core::clone::Clone::clone(
                        &self.element_form_default,
                    ),
                    attribute_form_default: ::core::clone::Clone::clone(
                        &self.attribute_form_default,
                    ),
                    imports: ::core::clone::Clone::clone(&self.imports),
                    elements: ::core::clone::Clone::clone(&self.elements),
                    simple_type: ::core::clone::Clone::clone(&self.simple_type),
                    complex_type: ::core::clone::Clone::clone(&self.complex_type),
                    attribute: ::core::clone::Clone::clone(&self.attribute),
                    attribute_group: ::core::clone::Clone::clone(&self.attribute_group),
                    group: ::core::clone::Clone::clone(&self.group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Schema {
            #[inline]
            fn default() -> Schema {
                Schema {
                    xmlns: ::core::default::Default::default(),
                    target_namespace: ::core::default::Default::default(),
                    element_form_default: ::core::default::Default::default(),
                    attribute_form_default: ::core::default::Default::default(),
                    imports: ::core::default::Default::default(),
                    elements: ::core::default::Default::default(),
                    simple_type: ::core::default::Default::default(),
                    complex_type: ::core::default::Default::default(),
                    attribute: ::core::default::Default::default(),
                    attribute_group: ::core::default::Default::default(),
                    group: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Schema {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "xmlns",
                    "target_namespace",
                    "element_form_default",
                    "attribute_form_default",
                    "imports",
                    "elements",
                    "simple_type",
                    "complex_type",
                    "attribute",
                    "attribute_group",
                    "group",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.xmlns,
                    &self.target_namespace,
                    &self.element_form_default,
                    &self.attribute_form_default,
                    &self.imports,
                    &self.elements,
                    &self.simple_type,
                    &self.complex_type,
                    &self.attribute,
                    &self.attribute_group,
                    &&self.group,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Schema",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Schema {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Schema {
            #[inline]
            fn eq(&self, other: &Schema) -> bool {
                self.xmlns == other.xmlns
                    && self.target_namespace == other.target_namespace
                    && self.element_form_default == other.element_form_default
                    && self.attribute_form_default == other.attribute_form_default
                    && self.imports == other.imports && self.elements == other.elements
                    && self.simple_type == other.simple_type
                    && self.complex_type == other.complex_type
                    && self.attribute == other.attribute
                    && self.attribute_group == other.attribute_group
                    && self.group == other.group
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Schema: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Schema {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("Schema"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Schema",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::schema",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __xmlns_value = None;
                    #[allow(unused_mut)]
                    let mut __target_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __element_form_default_value = None;
                    #[allow(unused_mut)]
                    let mut __attribute_form_default_value = None;
                    #[allow(unused_mut)]
                    let mut __imports_value: ::std::vec::Vec<import::Import> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __elements_value: ::std::vec::Vec<element::Element> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __simple_type_value: ::std::vec::Vec<types::SimpleType> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __complex_type_value: ::std::vec::Vec<types::ComplexType> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __attribute_value: ::std::vec::Vec<attribute::Attribute> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __attribute_group_value: ::std::vec::Vec<
                        attribute::AttributeGroup,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __group_value: ::std::vec::Vec<group::Group> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Xmlns_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Xmlns_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_TargetNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_TargetNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_ElementFormDefault_Form;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_ElementFormDefault_Form {
                        type Value = Form;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Form>", v, "</Form>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_AttributeFormDefault_Form;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_AttributeFormDefault_Form {
                        type Value = Form;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}{1}{2}", "<Form>", v, "</Form>"),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Schema",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::schema",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "import") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <import::Import as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __imports_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "element") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <element::Element as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __elements_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "simpleType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <types::SimpleType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __simple_type_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "complexType") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <types::ComplexType as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __complex_type_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "attribute") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <attribute::Attribute as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attribute_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "attributeGroup") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <attribute::AttributeGroup as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __attribute_group_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "group") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <group::Group as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __group_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "xmlns" {
                                            let visitor = __Visitor_Attribute_Xmlns_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xmlns_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "targetNamespace" {
                                            let visitor = __Visitor_Attribute_TargetNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __target_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "elementFormDefault" {
                                            let visitor = __Visitor_Attribute_ElementFormDefault_Form {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __element_form_default_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "attributeFormDefault" {
                                            let visitor = __Visitor_Attribute_AttributeFormDefault_Form {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __attribute_form_default_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Schema",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::schema",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Schema {
                        xmlns: __xmlns_value,
                        target_namespace: __target_namespace_value,
                        element_form_default: __element_form_default_value,
                        attribute_form_default: __attribute_form_default_value,
                        imports: __imports_value,
                        elements: __elements_value,
                        simple_type: __simple_type_value,
                        complex_type: __complex_type_value,
                        attribute: __attribute_value,
                        attribute_group: __attribute_group_value,
                        group: __group_value,
                    })
                }
            }
        };
    }
    pub mod sequence {
        use yaserde::*;
        use crate::xsd::default_fn::*;
        use crate::xsd::{
            annotation::Annotation, any::Any, element::Element, group::Group,
            max_occurences::MaxOccurences,
        };
        /**
 * <all
 *   id = ID
 *   maxOccurs = (0 | 1) : 1
 *   minOccurs = (0 | 1) : 1
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (element | any | group)*)
 * </all>
 */
        #[yaserde(
            rename = "all",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct All {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs", default = "default_u32_1")]
            pub max_occurs: u32,
            #[yaserde(attribute, rename = "minOccurs", default = "default_u32_1")]
            pub min_occurs: u32,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "element", prefix = "xs")]
            pub elements: Vec<Element>,
            #[yaserde(rename = "any", prefix = "xs")]
            pub any: Vec<Any>,
            #[yaserde(rename = "group", prefix = "xs")]
            pub groups: Vec<Group>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for All {
            #[inline]
            fn clone(&self) -> All {
                All {
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    elements: ::core::clone::Clone::clone(&self.elements),
                    any: ::core::clone::Clone::clone(&self.any),
                    groups: ::core::clone::Clone::clone(&self.groups),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for All {
            #[inline]
            fn default() -> All {
                All {
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    elements: ::core::default::Default::default(),
                    any: ::core::default::Default::default(),
                    groups: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for All {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "annotation",
                    "elements",
                    "any",
                    "groups",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.annotation,
                    &self.elements,
                    &self.any,
                    &&self.groups,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "All",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for All {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for All {
            #[inline]
            fn eq(&self, other: &All) -> bool {
                self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs
                    && self.annotation == other.annotation
                    && self.elements == other.elements && self.any == other.any
                    && self.groups == other.groups
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_All: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for All {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (::std::string::String::from("all"), ::std::option::Option::None)
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "All",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __elements_value: ::std::vec::Vec<Element> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __any_value: ::std::vec::Vec<Any> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __groups_value: ::std::vec::Vec<Group> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "All",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::sequence",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "element") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Element as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __elements_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "any") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Any as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "group") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Group as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __groups_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __max_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "All",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(All {
                        id: __id_value,
                        max_occurs: __max_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        min_occurs: __min_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        annotation: __annotation_value,
                        elements: __elements_value,
                        any: __any_value,
                        groups: __groups_value,
                    })
                }
            }
        };
        /**
 * <choice
 *   id = ID
 *   maxOccurs = (nonNegativeInteger | unbounded)  : 1
 *   minOccurs = nonNegativeInteger : 1
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (element | group | choice | sequence | any)*)
 * </choice>
 */
        #[yaserde(
            rename = "choice",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Choice {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs", default = "default_max_occurs")]
            pub max_occurs: MaxOccurences,
            #[yaserde(attribute, rename = "minOccurs", default = "default_u32_1")]
            pub min_occurs: u32,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "element", prefix = "xs")]
            pub elements: Vec<Element>,
            #[yaserde(rename = "group", prefix = "xs")]
            pub groups: Vec<Group>,
            #[yaserde(rename = "choice", prefix = "xs")]
            pub choices: Vec<Choice>,
            #[yaserde(rename = "sequence", prefix = "xs")]
            pub sequences: Vec<Sequence>,
            #[yaserde(rename = "any", prefix = "xs")]
            pub any: Vec<Any>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Choice {
            #[inline]
            fn clone(&self) -> Choice {
                Choice {
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    elements: ::core::clone::Clone::clone(&self.elements),
                    groups: ::core::clone::Clone::clone(&self.groups),
                    choices: ::core::clone::Clone::clone(&self.choices),
                    sequences: ::core::clone::Clone::clone(&self.sequences),
                    any: ::core::clone::Clone::clone(&self.any),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Choice {
            #[inline]
            fn default() -> Choice {
                Choice {
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    elements: ::core::default::Default::default(),
                    groups: ::core::default::Default::default(),
                    choices: ::core::default::Default::default(),
                    sequences: ::core::default::Default::default(),
                    any: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Choice {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "annotation",
                    "elements",
                    "groups",
                    "choices",
                    "sequences",
                    "any",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.annotation,
                    &self.elements,
                    &self.groups,
                    &self.choices,
                    &self.sequences,
                    &&self.any,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Choice",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Choice {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Choice {
            #[inline]
            fn eq(&self, other: &Choice) -> bool {
                self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs
                    && self.annotation == other.annotation
                    && self.elements == other.elements && self.groups == other.groups
                    && self.choices == other.choices && self.sequences == other.sequences
                    && self.any == other.any
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Choice: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Choice {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("choice"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Choice",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value: Option<MaxOccurences> = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __elements_value: ::std::vec::Vec<Element> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __groups_value: ::std::vec::Vec<Group> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __choices_value: ::std::vec::Vec<Choice> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __sequences_value: ::std::vec::Vec<Sequence> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __any_value: ::std::vec::Vec<Any> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_MaxOccurences;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_MaxOccurences {
                        type Value = MaxOccurences;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}{1}{2}",
                                        "<MaxOccurences>",
                                        v,
                                        "</MaxOccurences>",
                                    ),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Choice",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::sequence",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "element") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Element as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __elements_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "group") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Group as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __groups_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "choice") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Choice as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __choices_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "sequence") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __sequences_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "any") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Any as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_MaxOccurences {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __max_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Choice",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Choice {
                        id: __id_value,
                        max_occurs: __max_occurs_value
                            .unwrap_or_else(|| default_max_occurs()),
                        min_occurs: __min_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        annotation: __annotation_value,
                        elements: __elements_value,
                        groups: __groups_value,
                        choices: __choices_value,
                        sequences: __sequences_value,
                        any: __any_value,
                    })
                }
            }
        };
        /**
 * <sequence
 *   id = ID
 *   maxOccurs = (nonNegativeInteger | unbounded)  : 1
 *   minOccurs = nonNegativeInteger : 1
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (element | group | choice | sequence | any)*)
 * </sequence>
 */
        #[yaserde(
            rename = "sequence",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Sequence {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs", default = "default_max_occurs")]
            pub max_occurs: MaxOccurences,
            #[yaserde(attribute, rename = "minOccurs", default = "default_u32_1")]
            pub min_occurs: u32,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "element", prefix = "xs")]
            pub elements: Vec<Element>,
            #[yaserde(rename = "group", prefix = "xs")]
            pub groups: Vec<Group>,
            #[yaserde(rename = "choice", prefix = "xs")]
            pub choices: Vec<Choice>,
            #[yaserde(rename = "sequence", prefix = "xs")]
            pub sequences: Vec<Sequence>,
            #[yaserde(rename = "any", prefix = "xs")]
            pub any: Vec<Any>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Sequence {
            #[inline]
            fn clone(&self) -> Sequence {
                Sequence {
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    elements: ::core::clone::Clone::clone(&self.elements),
                    groups: ::core::clone::Clone::clone(&self.groups),
                    choices: ::core::clone::Clone::clone(&self.choices),
                    sequences: ::core::clone::Clone::clone(&self.sequences),
                    any: ::core::clone::Clone::clone(&self.any),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Sequence {
            #[inline]
            fn default() -> Sequence {
                Sequence {
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    elements: ::core::default::Default::default(),
                    groups: ::core::default::Default::default(),
                    choices: ::core::default::Default::default(),
                    sequences: ::core::default::Default::default(),
                    any: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Sequence {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "annotation",
                    "elements",
                    "groups",
                    "choices",
                    "sequences",
                    "any",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.annotation,
                    &self.elements,
                    &self.groups,
                    &self.choices,
                    &self.sequences,
                    &&self.any,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Sequence",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Sequence {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Sequence {
            #[inline]
            fn eq(&self, other: &Sequence) -> bool {
                self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs
                    && self.annotation == other.annotation
                    && self.elements == other.elements && self.groups == other.groups
                    && self.choices == other.choices && self.sequences == other.sequences
                    && self.any == other.any
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Sequence: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Sequence {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("sequence"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Sequence",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value: Option<MaxOccurences> = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __elements_value: ::std::vec::Vec<Element> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __groups_value: ::std::vec::Vec<Group> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __choices_value: ::std::vec::Vec<Choice> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __sequences_value: ::std::vec::Vec<Sequence> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __any_value: ::std::vec::Vec<Any> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_MaxOccurences;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_MaxOccurences {
                        type Value = MaxOccurences;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}{1}{2}",
                                        "<MaxOccurences>",
                                        v,
                                        "</MaxOccurences>",
                                    ),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Sequence",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::sequence",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "element") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Element as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __elements_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "group") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Group as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __groups_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "choice") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Choice as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __choices_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "sequence") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __sequences_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "any") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Any as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __any_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_MaxOccurences {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __max_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Sequence",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::sequence",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Sequence {
                        id: __id_value,
                        max_occurs: __max_occurs_value
                            .unwrap_or_else(|| default_max_occurs()),
                        min_occurs: __min_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        annotation: __annotation_value,
                        elements: __elements_value,
                        groups: __groups_value,
                        choices: __choices_value,
                        sequences: __sequences_value,
                        any: __any_value,
                    })
                }
            }
        };
    }
    pub mod type_def {
        use std::default;
        use crate::xsd::default_fn::*;
        use yaserde::*;
        use crate::xsd::{
            annotation::Annotation, sequence::{All, Choice, Sequence},
            element::TypeComponent, group::Group,
        };
        /**
 * <selector
 *   id = ID
 *   xpath = a subset of XPath expression, see below
 *   xpathDefaultNamespace = (anyURI | (##defaultNamespace | ##targetNamespace | ##local))
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </selector>
 */
        #[yaserde(
            rename = "selector",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Selector {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "xpath")]
            pub xpath: String,
            #[yaserde(attribute, rename = "xpathDefaultNamespace")]
            pub xpath_default_namespace: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Selector {
            #[inline]
            fn clone(&self) -> Selector {
                Selector {
                    id: ::core::clone::Clone::clone(&self.id),
                    xpath: ::core::clone::Clone::clone(&self.xpath),
                    xpath_default_namespace: ::core::clone::Clone::clone(
                        &self.xpath_default_namespace,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Selector {
            #[inline]
            fn default() -> Selector {
                Selector {
                    id: ::core::default::Default::default(),
                    xpath: ::core::default::Default::default(),
                    xpath_default_namespace: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Selector {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Selector",
                    "id",
                    &self.id,
                    "xpath",
                    &self.xpath,
                    "xpath_default_namespace",
                    &self.xpath_default_namespace,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Selector {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Selector {
            #[inline]
            fn eq(&self, other: &Selector) -> bool {
                self.id == other.id && self.xpath == other.xpath
                    && self.xpath_default_namespace == other.xpath_default_namespace
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Selector: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Selector {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("selector"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Selector",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __xpath_value: Option<::std::string::String> = None;
                    #[allow(unused_mut)]
                    let mut __xpath_default_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Xpath_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Xpath_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_XpathDefaultNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_XpathDefaultNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Selector",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpath" {
                                            __xpath_value = Some(attr.value.to_owned());
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpathDefaultNamespace" {
                                            let visitor = __Visitor_Attribute_XpathDefaultNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xpath_default_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Selector",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Selector {
                        id: __id_value,
                        xpath: __xpath_value
                            .ok_or_else(|| {
                                "xpath is a required field of Selector".to_string()
                            })?,
                        xpath_default_namespace: __xpath_default_namespace_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        /**
 * <field
 *   id = ID
 *   xpath = a subset of XPath expression, see below
 *   xpathDefaultNamespace = (anyURI | (##defaultNamespace | ##targetNamespace | ##local))
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </field>
 */
        #[yaserde(
            rename = "field",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Field {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "xpath")]
            pub xpath: String,
            #[yaserde(attribute, rename = "xpathDefaultNamespace")]
            pub xpath_default_namespace: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Field {
            #[inline]
            fn clone(&self) -> Field {
                Field {
                    id: ::core::clone::Clone::clone(&self.id),
                    xpath: ::core::clone::Clone::clone(&self.xpath),
                    xpath_default_namespace: ::core::clone::Clone::clone(
                        &self.xpath_default_namespace,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Field {
            #[inline]
            fn default() -> Field {
                Field {
                    id: ::core::default::Default::default(),
                    xpath: ::core::default::Default::default(),
                    xpath_default_namespace: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Field {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Field",
                    "id",
                    &self.id,
                    "xpath",
                    &self.xpath,
                    "xpath_default_namespace",
                    &self.xpath_default_namespace,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Field {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Field {
            #[inline]
            fn eq(&self, other: &Field) -> bool {
                self.id == other.id && self.xpath == other.xpath
                    && self.xpath_default_namespace == other.xpath_default_namespace
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Field: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Field {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("field"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Field",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __xpath_value: Option<::std::string::String> = None;
                    #[allow(unused_mut)]
                    let mut __xpath_default_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Xpath_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Xpath_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_XpathDefaultNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_XpathDefaultNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Field",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpath" {
                                            __xpath_value = Some(attr.value.to_owned());
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpathDefaultNamespace" {
                                            let visitor = __Visitor_Attribute_XpathDefaultNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xpath_default_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Field",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Field {
                        id: __id_value,
                        xpath: __xpath_value
                            .ok_or_else(|| {
                                "xpath is a required field of Field".to_string()
                            })?,
                        xpath_default_namespace: __xpath_default_namespace_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        /**
 * <unique
 *   id = ID
 *   name = NCName
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (selector, field+)?)
 * </unique>
 */
        #[yaserde(
            rename = "unique",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Unique {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute)]
            pub reference: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "selector", prefix = "xs")]
            pub selector: Option<Selector>,
            #[yaserde(rename = "field", prefix = "xs")]
            pub fields: Vec<Field>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Unique {
            #[inline]
            fn clone(&self) -> Unique {
                Unique {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    reference: ::core::clone::Clone::clone(&self.reference),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    selector: ::core::clone::Clone::clone(&self.selector),
                    fields: ::core::clone::Clone::clone(&self.fields),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Unique {
            #[inline]
            fn default() -> Unique {
                Unique {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    selector: ::core::default::Default::default(),
                    fields: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Unique {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "reference",
                    "annotation",
                    "selector",
                    "fields",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.reference,
                    &self.annotation,
                    &self.selector,
                    &&self.fields,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Unique",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Unique {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Unique {
            #[inline]
            fn eq(&self, other: &Unique) -> bool {
                self.id == other.id && self.name == other.name
                    && self.reference == other.reference
                    && self.annotation == other.annotation
                    && self.selector == other.selector && self.fields == other.fields
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Unique: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Unique {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("unique"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Unique",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __reference_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __selector_value = None;
                    #[allow(unused_mut)]
                    let mut __fields_value: ::std::vec::Vec<Field> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Reference_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Reference_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Unique",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "selector") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Selector as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __selector_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "field") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Field as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __fields_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "reference" {
                                            let visitor = __Visitor_Attribute_Reference_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __reference_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Unique",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Unique {
                        id: __id_value,
                        name: __name_value,
                        reference: __reference_value,
                        annotation: __annotation_value,
                        selector: __selector_value,
                        fields: __fields_value,
                    })
                }
            }
        };
        /**
 * <key
 *   id = ID
 *   name = NCName
 *   ref = QName
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (selector, field+)?)
 * </key>
 */
        #[yaserde(
            rename = "key",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Key {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute)]
            pub reference: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "selector", prefix = "xs")]
            pub selector: Option<Selector>,
            #[yaserde(rename = "field", prefix = "xs")]
            pub fields: Vec<Field>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Key {
            #[inline]
            fn clone(&self) -> Key {
                Key {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    reference: ::core::clone::Clone::clone(&self.reference),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    selector: ::core::clone::Clone::clone(&self.selector),
                    fields: ::core::clone::Clone::clone(&self.fields),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Key {
            #[inline]
            fn default() -> Key {
                Key {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    selector: ::core::default::Default::default(),
                    fields: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Key {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "reference",
                    "annotation",
                    "selector",
                    "fields",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.reference,
                    &self.annotation,
                    &self.selector,
                    &&self.fields,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Key",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Key {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Key {
            #[inline]
            fn eq(&self, other: &Key) -> bool {
                self.id == other.id && self.name == other.name
                    && self.reference == other.reference
                    && self.annotation == other.annotation
                    && self.selector == other.selector && self.fields == other.fields
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Key: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Key {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (::std::string::String::from("key"), ::std::option::Option::None)
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Key",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __reference_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __selector_value = None;
                    #[allow(unused_mut)]
                    let mut __fields_value: ::std::vec::Vec<Field> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Reference_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Reference_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Key",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "selector") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Selector as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __selector_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "field") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Field as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __fields_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "reference" {
                                            let visitor = __Visitor_Attribute_Reference_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __reference_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Key",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Key {
                        id: __id_value,
                        name: __name_value,
                        reference: __reference_value,
                        annotation: __annotation_value,
                        selector: __selector_value,
                        fields: __fields_value,
                    })
                }
            }
        };
        /**
 * <keyref
 *   id = ID
 *   name = NCName
 *   ref = QName
 *   refer = QName
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (selector, field+)?)
 * </keyref>
 */
        #[yaserde(
            rename = "keyref",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct KeyRef {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub name: Option<String>,
            #[yaserde(attribute)]
            pub reference: Option<String>,
            #[yaserde(attribute, rename = "refer")]
            pub refer: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(rename = "selector", prefix = "xs")]
            pub selector: Option<Selector>,
            #[yaserde(rename = "field", prefix = "xs")]
            pub fields: Vec<Field>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KeyRef {
            #[inline]
            fn clone(&self) -> KeyRef {
                KeyRef {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    reference: ::core::clone::Clone::clone(&self.reference),
                    refer: ::core::clone::Clone::clone(&self.refer),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    selector: ::core::clone::Clone::clone(&self.selector),
                    fields: ::core::clone::Clone::clone(&self.fields),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for KeyRef {
            #[inline]
            fn default() -> KeyRef {
                KeyRef {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    reference: ::core::default::Default::default(),
                    refer: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    selector: ::core::default::Default::default(),
                    fields: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KeyRef {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "reference",
                    "refer",
                    "annotation",
                    "selector",
                    "fields",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.reference,
                    &self.refer,
                    &self.annotation,
                    &self.selector,
                    &&self.fields,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "KeyRef",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KeyRef {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KeyRef {
            #[inline]
            fn eq(&self, other: &KeyRef) -> bool {
                self.id == other.id && self.name == other.name
                    && self.reference == other.reference && self.refer == other.refer
                    && self.annotation == other.annotation
                    && self.selector == other.selector && self.fields == other.fields
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_KeyRef: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for KeyRef {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("keyref"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "KeyRef",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __name_value = None;
                    #[allow(unused_mut)]
                    let mut __reference_value = None;
                    #[allow(unused_mut)]
                    let mut __refer_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __selector_value = None;
                    #[allow(unused_mut)]
                    let mut __fields_value: ::std::vec::Vec<Field> = ::alloc::vec::Vec::new();
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Name_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Name_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Reference_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Reference_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Refer_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Refer_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "KeyRef",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "selector") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Selector as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __selector_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        ("http://www.w3.org/2001/XMLSchema", "field") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Field as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __fields_value.push(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "name" {
                                            let visitor = __Visitor_Attribute_Name_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __name_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "reference" {
                                            let visitor = __Visitor_Attribute_Reference_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __reference_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "refer" {
                                            let visitor = __Visitor_Attribute_Refer_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __refer_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "KeyRef",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(KeyRef {
                        id: __id_value,
                        name: __name_value,
                        reference: __reference_value,
                        refer: __refer_value,
                        annotation: __annotation_value,
                        selector: __selector_value,
                        fields: __fields_value,
                    })
                }
            }
        };
        /**
 * <alternative
 *   id = ID
 *   test = an XPath expression
 *   type = QName
 *   xpathDefaultNamespace = (anyURI | (##defaultNamespace | ##targetNamespace | ##local))
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?, (simpleType | complexType)?)
 * </alternative>
 */
        #[yaserde(
            rename = "alternative",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Alternative {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub test: Option<String>,
            #[yaserde(attribute, rename = "type")]
            pub type_v: Option<String>,
            #[yaserde(attribute, rename = "xpathDefaultNamespace")]
            pub xpath_default_namespace: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
            #[yaserde(flatten)]
            pub type_component: TypeComponent,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Alternative {
            #[inline]
            fn clone(&self) -> Alternative {
                Alternative {
                    id: ::core::clone::Clone::clone(&self.id),
                    test: ::core::clone::Clone::clone(&self.test),
                    type_v: ::core::clone::Clone::clone(&self.type_v),
                    xpath_default_namespace: ::core::clone::Clone::clone(
                        &self.xpath_default_namespace,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                    type_component: ::core::clone::Clone::clone(&self.type_component),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Alternative {
            #[inline]
            fn default() -> Alternative {
                Alternative {
                    id: ::core::default::Default::default(),
                    test: ::core::default::Default::default(),
                    type_v: ::core::default::Default::default(),
                    xpath_default_namespace: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                    type_component: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Alternative {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "test",
                    "type_v",
                    "xpath_default_namespace",
                    "annotation",
                    "type_component",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.test,
                    &self.type_v,
                    &self.xpath_default_namespace,
                    &self.annotation,
                    &&self.type_component,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Alternative",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Alternative {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Alternative {
            #[inline]
            fn eq(&self, other: &Alternative) -> bool {
                self.id == other.id && self.test == other.test
                    && self.type_v == other.type_v
                    && self.xpath_default_namespace == other.xpath_default_namespace
                    && self.annotation == other.annotation
                    && self.type_component == other.type_component
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Alternative: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Alternative {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("alternative"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Alternative",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __test_value = None;
                    #[allow(unused_mut)]
                    let mut __type_v_value = None;
                    #[allow(unused_mut)]
                    let mut __xpath_default_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(unused_mut)]
                    let mut __type_component_value: Option<TypeComponent> = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Test_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Test_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Type_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Type_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_XpathDefaultNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_XpathDefaultNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut buf = ::alloc::vec::Vec::new();
                    let mut writer = ::std::option::Option::Some(
                        ::yaserde::__xml::writer::EventWriter::new(&mut buf),
                    );
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Alternative",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if let ::std::option::Option::Some(ref mut w) = writer {
                                                if w.write(event.as_writer_event().unwrap()).is_err() {
                                                    writer = ::std::option::Option::None;
                                                }
                                            }
                                            if depth > 0 {
                                                reader
                                                    .skip_element(|event| {
                                                        if let ::std::option::Option::Some(ref mut w) = writer {
                                                            if w.write(event.as_writer_event().unwrap()).is_err() {
                                                                writer = ::std::option::Option::None;
                                                            }
                                                        }
                                                    })?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "test" {
                                            let visitor = __Visitor_Attribute_Test_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __test_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "type" {
                                            let visitor = __Visitor_Attribute_Type_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __type_v_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpathDefaultNamespace" {
                                            let visitor = __Visitor_Attribute_XpathDefaultNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xpath_default_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    if let ::std::option::Option::Some(ref mut w) = writer {
                                        if w.write(event.as_writer_event().unwrap()).is_err() {
                                            writer = ::std::option::Option::None;
                                        }
                                    }
                                    break;
                                }
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                                if let ::std::option::Option::Some(ref mut w) = writer {
                                    if w.write(event.as_writer_event().unwrap()).is_err() {
                                        writer = ::std::option::Option::None;
                                    }
                                }
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    if writer.is_some() {
                        let unused_xml_elements = ::std::string::String::from_utf8(buf)
                            .unwrap();
                        __type_component_value = Some(
                            ::yaserde::de::from_str(&unused_xml_elements)?,
                        );
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Alternative",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Alternative {
                        id: __id_value,
                        test: __test_value,
                        type_v: __type_v_value,
                        xpath_default_namespace: __xpath_default_namespace_value,
                        annotation: __annotation_value,
                        type_component: __type_component_value
                            .ok_or_else(|| {
                                "type_component is a required field of Alternative"
                                    .to_string()
                            })?,
                    })
                }
            }
        };
        /**
 * <assert
 *   id = ID
 *   test = an XPath expression
 *   xpathDefaultNamespace = (anyURI | (##defaultNamespace | ##targetNamespace | ##local))
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </assert>
 */
        #[yaserde(
            rename = "assert",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Assert {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub test: Option<String>,
            #[yaserde(attribute, rename = "xpathDefaultNamespace")]
            pub xpath_default_namespace: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Assert {
            #[inline]
            fn clone(&self) -> Assert {
                Assert {
                    id: ::core::clone::Clone::clone(&self.id),
                    test: ::core::clone::Clone::clone(&self.test),
                    xpath_default_namespace: ::core::clone::Clone::clone(
                        &self.xpath_default_namespace,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Assert {
            #[inline]
            fn default() -> Assert {
                Assert {
                    id: ::core::default::Default::default(),
                    test: ::core::default::Default::default(),
                    xpath_default_namespace: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Assert {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Assert",
                    "id",
                    &self.id,
                    "test",
                    &self.test,
                    "xpath_default_namespace",
                    &self.xpath_default_namespace,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Assert {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Assert {
            #[inline]
            fn eq(&self, other: &Assert) -> bool {
                self.id == other.id && self.test == other.test
                    && self.xpath_default_namespace == other.xpath_default_namespace
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Assert: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Assert {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("assert"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Assert",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __test_value = None;
                    #[allow(unused_mut)]
                    let mut __xpath_default_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Test_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Test_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_XpathDefaultNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_XpathDefaultNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Assert",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "test" {
                                            let visitor = __Visitor_Attribute_Test_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __test_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpathDefaultNamespace" {
                                            let visitor = __Visitor_Attribute_XpathDefaultNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xpath_default_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Assert",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Assert {
                        id: __id_value,
                        test: __test_value,
                        xpath_default_namespace: __xpath_default_namespace_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        pub enum Form {
            #[default]
            #[yaserde(rename = "qualified")]
            Qualified,
            #[yaserde(rename = "unqualified")]
            Unqualified,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Form {
            #[inline]
            fn clone(&self) -> Form {
                match self {
                    Form::Qualified => Form::Qualified,
                    Form::Unqualified => Form::Unqualified,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Form {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Form::Qualified => "Qualified",
                        Form::Unqualified => "Unqualified",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Form {
            #[inline]
            fn default() -> Form {
                Self::Qualified
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Form {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Form {
            #[inline]
            fn eq(&self, other: &Form) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Form: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Form {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("Form"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "Form",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "Form",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "qualified" => {
                                        enum_value = ::std::option::Option::Some(Form::Qualified);
                                        break;
                                    }
                                    "unqualified" => {
                                        enum_value = ::std::option::Option::Some(Form::Unqualified);
                                        break;
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "qualified" => {
                                            enum_value = ::std::option::Option::Some(Form::Qualified);
                                            break;
                                        }
                                        "unqualified" => {
                                            enum_value = ::std::option::Option::Some(Form::Unqualified);
                                            break;
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "Form",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(<Form as ::std::default::Default>::default()),
                    )
                }
            }
        };
        pub enum ProcessContents {
            #[yaserde(rename = "lax")]
            Lax,
            #[yaserde(rename = "skip")]
            Skip,
            #[default]
            #[yaserde(rename = "strict")]
            Strict,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProcessContents {
            #[inline]
            fn clone(&self) -> ProcessContents {
                match self {
                    ProcessContents::Lax => ProcessContents::Lax,
                    ProcessContents::Skip => ProcessContents::Skip,
                    ProcessContents::Strict => ProcessContents::Strict,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ProcessContents {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ProcessContents::Lax => "Lax",
                        ProcessContents::Skip => "Skip",
                        ProcessContents::Strict => "Strict",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ProcessContents {
            #[inline]
            fn default() -> ProcessContents {
                Self::Strict
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ProcessContents {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ProcessContents {
            #[inline]
            fn eq(&self, other: &ProcessContents) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ProcessContents: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ProcessContents {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("ProcessContents"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "ProcessContents",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "ProcessContents",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "lax" => {
                                        enum_value = ::std::option::Option::Some(
                                            ProcessContents::Lax,
                                        );
                                        break;
                                    }
                                    "skip" => {
                                        enum_value = ::std::option::Option::Some(
                                            ProcessContents::Skip,
                                        );
                                        break;
                                    }
                                    "strict" => {
                                        enum_value = ::std::option::Option::Some(
                                            ProcessContents::Strict,
                                        );
                                        break;
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "lax" => {
                                            enum_value = ::std::option::Option::Some(
                                                ProcessContents::Lax,
                                            );
                                            break;
                                        }
                                        "skip" => {
                                            enum_value = ::std::option::Option::Some(
                                                ProcessContents::Skip,
                                            );
                                            break;
                                        }
                                        "strict" => {
                                            enum_value = ::std::option::Option::Some(
                                                ProcessContents::Strict,
                                            );
                                            break;
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "ProcessContents",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <ProcessContents as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        #[yaserde(prefix = "xs", namespace = "xs: http://www.w3.org/2001/XMLSchema")]
        pub enum ComplexChildren {
            #[default]
            None,
            #[yaserde(rename = "group", prefix = "xs")]
            Group(Group),
            #[yaserde(rename = "all", prefix = "xs")]
            All(All),
            #[yaserde(rename = "choice", prefix = "xs")]
            Choice(Choice),
            #[yaserde(rename = "sequence", prefix = "xs")]
            Sequence(Sequence),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ComplexChildren {
            #[inline]
            fn clone(&self) -> ComplexChildren {
                match self {
                    ComplexChildren::None => ComplexChildren::None,
                    ComplexChildren::Group(__self_0) => {
                        ComplexChildren::Group(::core::clone::Clone::clone(__self_0))
                    }
                    ComplexChildren::All(__self_0) => {
                        ComplexChildren::All(::core::clone::Clone::clone(__self_0))
                    }
                    ComplexChildren::Choice(__self_0) => {
                        ComplexChildren::Choice(::core::clone::Clone::clone(__self_0))
                    }
                    ComplexChildren::Sequence(__self_0) => {
                        ComplexChildren::Sequence(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ComplexChildren {
            #[inline]
            fn default() -> ComplexChildren {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ComplexChildren {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ComplexChildren::None => ::core::fmt::Formatter::write_str(f, "None"),
                    ComplexChildren::Group(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Group",
                            &__self_0,
                        )
                    }
                    ComplexChildren::All(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "All",
                            &__self_0,
                        )
                    }
                    ComplexChildren::Choice(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Choice",
                            &__self_0,
                        )
                    }
                    ComplexChildren::Sequence(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sequence",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ComplexChildren {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ComplexChildren {
            #[inline]
            fn eq(&self, other: &ComplexChildren) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            ComplexChildren::Group(__self_0),
                            ComplexChildren::Group(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexChildren::All(__self_0),
                            ComplexChildren::All(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexChildren::Choice(__self_0),
                            ComplexChildren::Choice(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            ComplexChildren::Sequence(__self_0),
                            ComplexChildren::Sequence(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ComplexChildren: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ComplexChildren {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, enum_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("ComplexChildren"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: start to parse {2:?}",
                                    "ComplexChildren",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if let Some(namespace) = enum_namespace {
                        match namespace.as_str() {
                            "http://www.w3.org/2001/XMLSchema" => {}
                            bad_namespace => {
                                let msg = ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "bad namespace for {0}, found {1}",
                                            named_element,
                                            bad_namespace,
                                        ),
                                    );
                                    res
                                });
                                return Err(msg);
                            }
                        }
                    }
                    #[allow(unused_assignments, unused_mut)]
                    let mut enum_value = ::std::option::Option::None;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Enum {0} @ {1}: matching {2:?}",
                                        "ComplexChildren",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                match name.local_name.as_str() {
                                    "None" => {
                                        enum_value = ::std::option::Option::Some(
                                            ComplexChildren::None,
                                        );
                                        break;
                                    }
                                    "group" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Group;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Group" + ">" + v + "</"
                                                    + "Group" + ">";
                                                let value: ::std::result::Result<
                                                    Group,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Group as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexChildren::Group(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "all" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = All;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "All" + ">" + v + "</"
                                                    + "All" + ">";
                                                let value: ::std::result::Result<
                                                    All,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <All as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexChildren::All(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "choice" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Choice;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Choice" + ">" + v + "</"
                                                    + "Choice" + ">";
                                                let value: ::std::result::Result<
                                                    Choice,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Choice as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexChildren::Choice(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    "sequence" => {
                                        #[allow(non_snake_case, non_camel_case_types)]
                                        struct __Visitor_0;
                                        impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                            type Value = Sequence;
                                            fn visit_str(
                                                self,
                                                v: &str,
                                            ) -> ::std::result::Result<
                                                Self::Value,
                                                ::std::string::String,
                                            > {
                                                let content = "<".to_string() + "Sequence" + ">" + v + "</"
                                                    + "Sequence" + ">";
                                                let value: ::std::result::Result<
                                                    Sequence,
                                                    ::std::string::String,
                                                > = ::yaserde::de::from_str(&content);
                                                value
                                            }
                                        }
                                        match <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                            reader,
                                        ) {
                                            Ok(value) => {
                                                enum_value = ::std::option::Option::Some(
                                                    ComplexChildren::Sequence(value),
                                                );
                                                let _root = reader.next_event();
                                            }
                                            Err(msg) => {
                                                return Err(msg);
                                            }
                                        }
                                    }
                                    _named_element => {
                                        let _root = reader.next_event();
                                    }
                                }
                                if let ::yaserde::__xml::reader::XmlEvent::Characters(
                                    content,
                                ) = reader.peek()?.to_owned()
                                {
                                    match content.as_str() {
                                        "None" => {
                                            enum_value = ::std::option::Option::Some(
                                                ComplexChildren::None,
                                            );
                                            break;
                                        }
                                        "group" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Group;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Group" + ">" + v + "</"
                                                        + "Group" + ">";
                                                    let value: ::std::result::Result<
                                                        Group,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Group as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexChildren::Group(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "all" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = All;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "All" + ">" + v + "</"
                                                        + "All" + ">";
                                                    let value: ::std::result::Result<
                                                        All,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <All as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexChildren::All(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "choice" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Choice;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Choice" + ">" + v + "</"
                                                        + "Choice" + ">";
                                                    let value: ::std::result::Result<
                                                        Choice,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Choice as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexChildren::Choice(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        "sequence" => {
                                            #[allow(non_snake_case, non_camel_case_types)]
                                            struct __Visitor_0;
                                            impl<'de> ::yaserde::Visitor<'de> for __Visitor_0 {
                                                type Value = Sequence;
                                                fn visit_str(
                                                    self,
                                                    v: &str,
                                                ) -> ::std::result::Result<
                                                    Self::Value,
                                                    ::std::string::String,
                                                > {
                                                    let content = "<".to_string() + "Sequence" + ">" + v + "</"
                                                        + "Sequence" + ">";
                                                    let value: ::std::result::Result<
                                                        Sequence,
                                                        ::std::string::String,
                                                    > = ::yaserde::de::from_str(&content);
                                                    value
                                                }
                                            }
                                            match <Sequence as ::yaserde::YaDeserialize>::deserialize(
                                                reader,
                                            ) {
                                                Ok(value) => {
                                                    enum_value = ::std::option::Option::Some(
                                                        ComplexChildren::Sequence(value),
                                                    );
                                                    let _root = reader.next_event();
                                                }
                                                Err(msg) => {
                                                    return Err(msg);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let _root = reader.next_event();
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("End of document, missing some content ?"),
                                        );
                                        res
                                    }),
                                );
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Enum {0} @ {1}: success",
                                    "ComplexChildren",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(
                        enum_value
                            .unwrap_or(
                                <ComplexChildren as ::std::default::Default>::default(),
                            ),
                    )
                }
            }
        };
        #[yaserde(
            rename = "minExclusive",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MinExclusive {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<f32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MinExclusive {
            #[inline]
            fn clone(&self) -> MinExclusive {
                MinExclusive {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MinExclusive {
            #[inline]
            fn default() -> MinExclusive {
                MinExclusive {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MinExclusive {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MinExclusive",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MinExclusive {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MinExclusive {
            #[inline]
            fn eq(&self, other: &MinExclusive) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MinExclusive: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MinExclusive {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("minExclusive"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MinExclusive",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = f32;
                        fn visit_f32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            f32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MinExclusive",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_f32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MinExclusive",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MinExclusive {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "minInclusive",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MinInclusive {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<f32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MinInclusive {
            #[inline]
            fn clone(&self) -> MinInclusive {
                MinInclusive {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MinInclusive {
            #[inline]
            fn default() -> MinInclusive {
                MinInclusive {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MinInclusive {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MinInclusive",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MinInclusive {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MinInclusive {
            #[inline]
            fn eq(&self, other: &MinInclusive) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MinInclusive: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MinInclusive {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("minInclusive"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MinInclusive",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = f32;
                        fn visit_f32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            f32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MinInclusive",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_f32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MinInclusive",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MinInclusive {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "maxExclusive",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MaxExclusive {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<f32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MaxExclusive {
            #[inline]
            fn clone(&self) -> MaxExclusive {
                MaxExclusive {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MaxExclusive {
            #[inline]
            fn default() -> MaxExclusive {
                MaxExclusive {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MaxExclusive {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MaxExclusive",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MaxExclusive {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MaxExclusive {
            #[inline]
            fn eq(&self, other: &MaxExclusive) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MaxExclusive: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MaxExclusive {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("maxExclusive"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MaxExclusive",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = f32;
                        fn visit_f32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            f32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MaxExclusive",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_f32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MaxExclusive",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MaxExclusive {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "maxInclusive",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MaxInclusive {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<f32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MaxInclusive {
            #[inline]
            fn clone(&self) -> MaxInclusive {
                MaxInclusive {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MaxInclusive {
            #[inline]
            fn default() -> MaxInclusive {
                MaxInclusive {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MaxInclusive {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MaxInclusive",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MaxInclusive {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MaxInclusive {
            #[inline]
            fn eq(&self, other: &MaxInclusive) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MaxInclusive: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MaxInclusive {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("maxInclusive"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MaxInclusive",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = f32;
                        fn visit_f32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            f32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MaxInclusive",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_f32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MaxInclusive",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MaxInclusive {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "totalDigits",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct TotalDigits {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<u32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TotalDigits {
            #[inline]
            fn clone(&self) -> TotalDigits {
                TotalDigits {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TotalDigits {
            #[inline]
            fn default() -> TotalDigits {
                TotalDigits {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TotalDigits {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "TotalDigits",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TotalDigits {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TotalDigits {
            #[inline]
            fn eq(&self, other: &TotalDigits) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_TotalDigits: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for TotalDigits {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("totalDigits"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "TotalDigits",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "TotalDigits",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "TotalDigits",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(TotalDigits {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "fractionDigits",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct FractionDigits {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<u32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FractionDigits {
            #[inline]
            fn clone(&self) -> FractionDigits {
                FractionDigits {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for FractionDigits {
            #[inline]
            fn default() -> FractionDigits {
                FractionDigits {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FractionDigits {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "FractionDigits",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FractionDigits {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FractionDigits {
            #[inline]
            fn eq(&self, other: &FractionDigits) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_FractionDigits: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for FractionDigits {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("fractionDigits"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "FractionDigits",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "FractionDigits",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "FractionDigits",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(FractionDigits {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "length",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Length {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<u32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Length {
            #[inline]
            fn clone(&self) -> Length {
                Length {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Length {
            #[inline]
            fn default() -> Length {
                Length {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Length {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Length",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Length {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Length {
            #[inline]
            fn eq(&self, other: &Length) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Length: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Length {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("length"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Length",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Length",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Length",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Length {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "minLength",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MinLength {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<u32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MinLength {
            #[inline]
            fn clone(&self) -> MinLength {
                MinLength {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MinLength {
            #[inline]
            fn default() -> MinLength {
                MinLength {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MinLength {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MinLength",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MinLength {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MinLength {
            #[inline]
            fn eq(&self, other: &MinLength) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MinLength: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MinLength {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("minLength"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MinLength",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MinLength",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MinLength",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MinLength {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "maxLength",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct MaxLength {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<u32>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MaxLength {
            #[inline]
            fn clone(&self) -> MaxLength {
                MaxLength {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MaxLength {
            #[inline]
            fn default() -> MaxLength {
                MaxLength {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MaxLength {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MaxLength",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MaxLength {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MaxLength {
            #[inline]
            fn eq(&self, other: &MaxLength) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_MaxLength: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for MaxLength {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("maxLength"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "MaxLength",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "MaxLength",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "MaxLength",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(MaxLength {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "enumeration",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Enumeration {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Enumeration {
            #[inline]
            fn clone(&self) -> Enumeration {
                Enumeration {
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Enumeration {
            #[inline]
            fn default() -> Enumeration {
                Enumeration {
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Enumeration {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Enumeration",
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Enumeration {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Enumeration {
            #[inline]
            fn eq(&self, other: &Enumeration) -> bool {
                self.id == other.id && self.value == other.value
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Enumeration: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Enumeration {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("enumeration"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Enumeration",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Enumeration",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Enumeration",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Enumeration {
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "whiteSpace",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct WhiteSpace {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WhiteSpace {
            #[inline]
            fn clone(&self) -> WhiteSpace {
                WhiteSpace {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for WhiteSpace {
            #[inline]
            fn default() -> WhiteSpace {
                WhiteSpace {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WhiteSpace {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "WhiteSpace",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for WhiteSpace {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for WhiteSpace {
            #[inline]
            fn eq(&self, other: &WhiteSpace) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_WhiteSpace: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for WhiteSpace {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("whiteSpace"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "WhiteSpace",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "WhiteSpace",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "WhiteSpace",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(WhiteSpace {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "pattern",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Pattern {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Pattern {
            #[inline]
            fn clone(&self) -> Pattern {
                Pattern {
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Pattern {
            #[inline]
            fn default() -> Pattern {
                Pattern {
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Pattern {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Pattern",
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Pattern {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Pattern {
            #[inline]
            fn eq(&self, other: &Pattern) -> bool {
                self.id == other.id && self.value == other.value
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Pattern: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Pattern {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("pattern"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Pattern",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Pattern",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Pattern",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Pattern {
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "assertion",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Assertion {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub test: Option<String>,
            #[yaserde(attribute, rename = "xpathDefaultNamespace")]
            pub xpath_default_namespace: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Assertion {
            #[inline]
            fn clone(&self) -> Assertion {
                Assertion {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    test: ::core::clone::Clone::clone(&self.test),
                    xpath_default_namespace: ::core::clone::Clone::clone(
                        &self.xpath_default_namespace,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Assertion {
            #[inline]
            fn default() -> Assertion {
                Assertion {
                    fixed: ::core::default::Default::default(),
                    test: ::core::default::Default::default(),
                    xpath_default_namespace: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Assertion {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Assertion",
                    "fixed",
                    &self.fixed,
                    "test",
                    &self.test,
                    "xpath_default_namespace",
                    &self.xpath_default_namespace,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Assertion {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Assertion {
            #[inline]
            fn eq(&self, other: &Assertion) -> bool {
                self.fixed == other.fixed && self.test == other.test
                    && self.xpath_default_namespace == other.xpath_default_namespace
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Assertion: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Assertion {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("assertion"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Assertion",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __test_value = None;
                    #[allow(unused_mut)]
                    let mut __xpath_default_namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Test_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Test_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_XpathDefaultNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_XpathDefaultNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Assertion",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "test" {
                                            let visitor = __Visitor_Attribute_Test_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __test_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "xpathDefaultNamespace" {
                                            let visitor = __Visitor_Attribute_XpathDefaultNamespace_ {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __xpath_default_namespace_value = ::std::option::Option::Some(
                                                value,
                                            );
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Assertion",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Assertion {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        test: __test_value,
                        xpath_default_namespace: __xpath_default_namespace_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
        #[yaserde(
            rename = "explicitTimezone",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct ExplicitTimezone {
            #[yaserde(attribute, default = "default_false")]
            pub fixed: bool,
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute)]
            pub value: Option<String>,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExplicitTimezone {
            #[inline]
            fn clone(&self) -> ExplicitTimezone {
                ExplicitTimezone {
                    fixed: ::core::clone::Clone::clone(&self.fixed),
                    id: ::core::clone::Clone::clone(&self.id),
                    value: ::core::clone::Clone::clone(&self.value),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ExplicitTimezone {
            #[inline]
            fn default() -> ExplicitTimezone {
                ExplicitTimezone {
                    fixed: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ExplicitTimezone {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ExplicitTimezone",
                    "fixed",
                    &self.fixed,
                    "id",
                    &self.id,
                    "value",
                    &self.value,
                    "annotation",
                    &&self.annotation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ExplicitTimezone {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ExplicitTimezone {
            #[inline]
            fn eq(&self, other: &ExplicitTimezone) -> bool {
                self.fixed == other.fixed && self.id == other.id
                    && self.value == other.value && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_ExplicitTimezone: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for ExplicitTimezone {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (
                            ::std::string::String::from("explicitTimezone"),
                            ::std::option::Option::None,
                        )
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "ExplicitTimezone",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __fixed_value: Option<bool> = None;
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __value_value = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Fixed_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Fixed_ {
                        type Value = bool;
                        fn visit_bool(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            bool::from_str(
                                    match v {
                                        "1" => "true",
                                        "0" => "false",
                                        _ => v,
                                    },
                                )
                                .map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Value_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Value_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "ExplicitTimezone",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::type_def",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "fixed" {
                                            let visitor = __Visitor_Attribute_Fixed_ {};
                                            let value = visitor.visit_bool(&attr.value)?;
                                            __fixed_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "value" {
                                            let visitor = __Visitor_Attribute_Value_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __value_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "ExplicitTimezone",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::type_def",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(ExplicitTimezone {
                        fixed: __fixed_value.unwrap_or_else(|| default_false()),
                        id: __id_value,
                        value: __value_value,
                        annotation: __annotation_value,
                    })
                }
            }
        };
    }
    pub mod any {
        use yaserde::*;
        use crate::xsd::default_fn::*;
        use crate::xsd::{
            annotation::Annotation, type_def::ProcessContents,
            max_occurences::MaxOccurences,
        };
        /**
 * <any
 *   id = ID
 *   maxOccurs = (nonNegativeInteger | unbounded)  : 1
 *   minOccurs = nonNegativeInteger : 1
 *   namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )
 *   notNamespace = List of (anyURI | (##targetNamespace | ##local))
 *   notQName = List of (QName | (##defined | ##definedSibling))
 *   processContents = (lax | skip | strict) : strict
 *   {any attributes with non-schema namespace . . .}>
 *     Content: (annotation?)
 * </any>
 */
        #[yaserde(
            rename = "any",
            prefix = "xs",
            namespace = "xs: http://www.w3.org/2001/XMLSchema"
        )]
        pub struct Any {
            #[yaserde(attribute)]
            pub id: Option<String>,
            #[yaserde(attribute, rename = "maxOccurs", default)]
            pub max_occurs: MaxOccurences,
            #[yaserde(attribute, rename = "minOccurs", default = "default_u32_1")]
            pub min_occurs: u32,
            #[yaserde(attribute)]
            pub namespace: Option<String>,
            #[yaserde(attribute, rename = "notNamespace")]
            pub not_namespace: Vec<String>,
            #[yaserde(attribute, rename = "notQName")]
            pub not_qname: Vec<String>,
            #[yaserde(attribute, rename = "processContents", default)]
            pub process_contents: ProcessContents,
            #[yaserde(rename = "annotation", prefix = "xs")]
            pub annotation: Option<Annotation>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Any {
            #[inline]
            fn clone(&self) -> Any {
                Any {
                    id: ::core::clone::Clone::clone(&self.id),
                    max_occurs: ::core::clone::Clone::clone(&self.max_occurs),
                    min_occurs: ::core::clone::Clone::clone(&self.min_occurs),
                    namespace: ::core::clone::Clone::clone(&self.namespace),
                    not_namespace: ::core::clone::Clone::clone(&self.not_namespace),
                    not_qname: ::core::clone::Clone::clone(&self.not_qname),
                    process_contents: ::core::clone::Clone::clone(
                        &self.process_contents,
                    ),
                    annotation: ::core::clone::Clone::clone(&self.annotation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Any {
            #[inline]
            fn default() -> Any {
                Any {
                    id: ::core::default::Default::default(),
                    max_occurs: ::core::default::Default::default(),
                    min_occurs: ::core::default::Default::default(),
                    namespace: ::core::default::Default::default(),
                    not_namespace: ::core::default::Default::default(),
                    not_qname: ::core::default::Default::default(),
                    process_contents: ::core::default::Default::default(),
                    annotation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Any {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "max_occurs",
                    "min_occurs",
                    "namespace",
                    "not_namespace",
                    "not_qname",
                    "process_contents",
                    "annotation",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.max_occurs,
                    &self.min_occurs,
                    &self.namespace,
                    &self.not_namespace,
                    &self.not_qname,
                    &self.process_contents,
                    &&self.annotation,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Any",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Any {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Any {
            #[inline]
            fn eq(&self, other: &Any) -> bool {
                self.id == other.id && self.max_occurs == other.max_occurs
                    && self.min_occurs == other.min_occurs
                    && self.namespace == other.namespace
                    && self.not_namespace == other.not_namespace
                    && self.not_qname == other.not_qname
                    && self.process_contents == other.process_contents
                    && self.annotation == other.annotation
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _IMPL_YA_DESERIALIZE_FOR_Any: () = {
            use ::std::str::FromStr as _;
            use ::yaserde::Visitor as _;
            impl ::yaserde::YaDeserialize for Any {
                #[allow(unused_variables)]
                fn deserialize<R: ::std::io::Read>(
                    reader: &mut ::yaserde::de::Deserializer<R>,
                ) -> ::std::result::Result<Self, ::std::string::String> {
                    let (named_element, struct_namespace) = if let ::yaserde::__xml::reader::XmlEvent::StartElement {
                        name,
                        ..
                    } = reader.peek()?.to_owned()
                    {
                        (name.local_name.to_owned(), name.namespace.clone())
                    } else {
                        (::std::string::String::from("any"), ::std::option::Option::None)
                    };
                    let start_depth = reader.depth();
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: start to parse {2:?}",
                                    "Any",
                                    start_depth,
                                    named_element,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::any",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if reader.depth() == 0 {
                        if let Some(namespace) = struct_namespace {
                            match namespace.as_str() {
                                "http://www.w3.org/2001/XMLSchema" => {}
                                bad_namespace => {
                                    let msg = ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "bad namespace for {0}, found {1}",
                                                named_element,
                                                bad_namespace,
                                            ),
                                        );
                                        res
                                    });
                                    return Err(msg);
                                }
                            }
                        }
                    }
                    #[allow(unused_mut)]
                    let mut __id_value = None;
                    #[allow(unused_mut)]
                    let mut __max_occurs_value: Option<MaxOccurences> = None;
                    #[allow(unused_mut)]
                    let mut __min_occurs_value: Option<u32> = None;
                    #[allow(unused_mut)]
                    let mut __namespace_value = None;
                    #[allow(unused_mut)]
                    let mut __not_namespace_value: ::std::vec::Vec<
                        ::std::string::String,
                    > = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __not_qname_value: ::std::vec::Vec<::std::string::String> = ::alloc::vec::Vec::new();
                    #[allow(unused_mut)]
                    let mut __process_contents_value: Option<ProcessContents> = None;
                    #[allow(unused_mut)]
                    let mut __annotation_value = None;
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Id_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_Id_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MaxOccurs_MaxOccurences;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MaxOccurs_MaxOccurences {
                        type Value = MaxOccurences;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}{1}{2}",
                                        "<MaxOccurences>",
                                        v,
                                        "</MaxOccurences>",
                                    ),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_MinOccurs_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_MinOccurs_ {
                        type Value = u32;
                        fn visit_u32(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            u32::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_Namespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_Namespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_NotNamespace_;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_NotNamespace_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_NotQName_;
                    impl<'de> ::yaserde::Visitor<'de> for __Visitor_Attribute_NotQName_ {
                        type Value = ::std::string::String;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            ::std::string::String::from_str(v).map_err(|e| e.to_string())
                        }
                    }
                    #[allow(non_snake_case, non_camel_case_types)]
                    struct __Visitor_Attribute_ProcessContents_ProcessContents;
                    impl<'de> ::yaserde::Visitor<'de>
                    for __Visitor_Attribute_ProcessContents_ProcessContents {
                        type Value = ProcessContents;
                        fn visit_str(
                            self,
                            v: &str,
                        ) -> ::std::result::Result<Self::Value, ::std::string::String> {
                            let content = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}{1}{2}",
                                        "<ProcessContents>",
                                        v,
                                        "</ProcessContents>",
                                    ),
                                );
                                res
                            });
                            ::yaserde::de::from_str(&content)
                        }
                    }
                    let mut depth = 0;
                    loop {
                        let event = reader.peek()?.to_owned();
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "Struct {0} @ {1}: matching {2:?}",
                                        "Any",
                                        start_depth,
                                        event,
                                    ),
                                    lvl,
                                    &(
                                        "yaserde_derive",
                                        "rs_xsd_parser::xsd::any",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        match event {
                            ::yaserde::__xml::reader::XmlEvent::StartElement {
                                ref name,
                                ref attributes,
                                ..
                            } => {
                                let namespace = name.namespace.clone().unwrap_or_default();
                                if depth == 0 {
                                    let event = reader.next_event()?;
                                } else {
                                    match (namespace.as_str(), name.local_name.as_str()) {
                                        ("http://www.w3.org/2001/XMLSchema", "annotation") => {
                                            if depth == 0 {
                                                let _root = reader.next_event();
                                            }
                                            if let Ok(
                                                ::yaserde::__xml::reader::XmlEvent::StartElement { .. },
                                            ) = reader.peek()
                                            {
                                                let value = <Annotation as ::yaserde::YaDeserialize>::deserialize(
                                                    reader,
                                                )?;
                                                __annotation_value = ::std::option::Option::Some(value);
                                                let _event = reader.next_event()?;
                                            }
                                        }
                                        _ => {
                                            let event = reader.next_event()?;
                                            if depth > 0 {
                                                reader.skip_element(|event| {})?;
                                            }
                                        }
                                    }
                                }
                                if depth == 0 {
                                    for attr in attributes {
                                        if attr.name.local_name == "id" {
                                            let visitor = __Visitor_Attribute_Id_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __id_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "maxOccurs" {
                                            let visitor = __Visitor_Attribute_MaxOccurs_MaxOccurences {
                                            };
                                            let value = visitor.visit_str(&attr.value)?;
                                            __max_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "minOccurs" {
                                            let visitor = __Visitor_Attribute_MinOccurs_ {};
                                            let value = visitor.visit_u32(&attr.value)?;
                                            __min_occurs_value = Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "namespace" {
                                            let visitor = __Visitor_Attribute_Namespace_ {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __namespace_value = ::std::option::Option::Some(value);
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "notNamespace" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_NotNamespace_ {
                                                };
                                                let value = visitor.visit_str(value)?;
                                                __not_namespace_value.push(value);
                                            }
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "notQName" {
                                            for value in attr.value.split_whitespace() {
                                                let visitor = __Visitor_Attribute_NotQName_ {};
                                                let value = visitor.visit_str(value)?;
                                                __not_qname_value.push(value);
                                            }
                                        }
                                    }
                                    for attr in attributes {
                                        if attr.name.local_name == "processContents" {
                                            let visitor = __Visitor_Attribute_ProcessContents_ProcessContents {};
                                            let value = visitor.visit_str(&attr.value)?;
                                            __process_contents_value = Some(value);
                                        }
                                    }
                                }
                                depth += 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndElement {
                                ref name,
                            } => {
                                if name.local_name == named_element
                                    && reader.depth() == start_depth + 1
                                {
                                    break;
                                }
                                let event = reader.next_event()?;
                                depth -= 1;
                            }
                            ::yaserde::__xml::reader::XmlEvent::EndDocument => {
                                if false {
                                    break;
                                }
                            }
                            ::yaserde::__xml::reader::XmlEvent::Characters(
                                ref text_content,
                            ) => {
                                let event = reader.next_event()?;
                            }
                            event => {
                                return ::std::result::Result::Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown event {0:?}", event),
                                        );
                                        res
                                    }),
                                );
                            }
                        }
                    }
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Struct {0} @ {1}: success",
                                    "Any",
                                    start_depth,
                                ),
                                lvl,
                                &(
                                    "yaserde_derive",
                                    "rs_xsd_parser::xsd::any",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    ::std::result::Result::Ok(Any {
                        id: __id_value,
                        max_occurs: __max_occurs_value
                            .ok_or_else(|| {
                                "max_occurs is a required field of Any".to_string()
                            })?,
                        min_occurs: __min_occurs_value
                            .unwrap_or_else(|| default_u32_1()),
                        namespace: __namespace_value,
                        not_namespace: __not_namespace_value,
                        not_qname: __not_qname_value,
                        process_contents: __process_contents_value
                            .ok_or_else(|| {
                                "process_contents is a required field of Any".to_string()
                            })?,
                        annotation: __annotation_value,
                    })
                }
            }
        };
    }
    pub mod default_fn {
        use super::max_occurences::MaxOccurences;
        pub fn default_true() -> bool {
            true
        }
        pub fn default_false() -> bool {
            false
        }
        pub fn default_u32_1() -> u32 {
            1
        }
        pub fn default_max_occurs() -> MaxOccurences {
            MaxOccurences::default()
        }
    }
    pub mod atomic_type {
        pub enum AtomicType {
            None,
            Other,
            AnyURI,
            Base64Binary,
            Boolean,
            Date,
            DateTime,
            DateTimeStamp,
            Decimal,
            Interger,
            Long,
            Int,
            Short,
            Byte,
            NonNegativeInteger,
            PositiveInteger,
            UnsignedLong,
            UnsignedInt,
            UnsignedShort,
            UnsignedByte,
            NonPositiveInteger,
            NegativeInteger,
            Double,
            Duration,
            DayTimeDuration,
            YearMonthDuration,
            Float,
            GDay,
            GMonth,
            GMonthDay,
            GYear,
            GYearMonth,
            HexBinary,
            NOTATION,
            QName,
            String,
            NormalizedString,
            Token,
            Language,
            Name,
            NCName,
            ENTITY,
            ID,
            IDREF,
            NMTOKEN,
            Time,
        }
        impl AtomicType {
            pub fn from_str(atomic_type: &str) -> Self {
                if atomic_type == "" {
                    return AtomicType::None;
                }
                match atomic_type.to_lowercase().as_str() {
                    "anyuri" => AtomicType::AnyURI,
                    "base64binary" => AtomicType::Base64Binary,
                    "boolean" => AtomicType::Boolean,
                    "date" => AtomicType::Date,
                    "datetime" => AtomicType::DateTime,
                    "datetimestamp" => AtomicType::DateTimeStamp,
                    "decimal" => AtomicType::Decimal,
                    "integer" => AtomicType::Interger,
                    "long" => AtomicType::Long,
                    "int" => AtomicType::Int,
                    "short" => AtomicType::Short,
                    "byte" => AtomicType::Byte,
                    "nonnegativeinteger" => AtomicType::NonNegativeInteger,
                    "positiveinteger" => AtomicType::PositiveInteger,
                    "unsignedlong" => AtomicType::UnsignedLong,
                    "unsignedint" => AtomicType::UnsignedInt,
                    "unsignedshort" => AtomicType::UnsignedShort,
                    "unsignedbyte" => AtomicType::UnsignedByte,
                    "nonpositiveinteger" => AtomicType::NonPositiveInteger,
                    "negativeinteger" => AtomicType::NegativeInteger,
                    "double" => AtomicType::Double,
                    "duration" => AtomicType::Duration,
                    "daytimeduration" => AtomicType::DayTimeDuration,
                    "yearmonthduration" => AtomicType::YearMonthDuration,
                    "float" => AtomicType::Float,
                    "gday" => AtomicType::GDay,
                    "gmonth" => AtomicType::GMonth,
                    "gmonthday" => AtomicType::GMonthDay,
                    "gyear" => AtomicType::GYear,
                    "gyearmonth" => AtomicType::GYearMonth,
                    "hexbinary" => AtomicType::HexBinary,
                    "notation" => AtomicType::NOTATION,
                    "qname" => AtomicType::QName,
                    "string" => AtomicType::String,
                    "normalizedstring" => AtomicType::NormalizedString,
                    "token" => AtomicType::Token,
                    "language" => AtomicType::Language,
                    "name" => AtomicType::Name,
                    "ncname" => AtomicType::NCName,
                    "entity" => AtomicType::ENTITY,
                    "id" => AtomicType::ID,
                    "idref" => AtomicType::IDREF,
                    "nmtoken" => AtomicType::NMTOKEN,
                    "time" => AtomicType::Time,
                    _ => AtomicType::Other,
                }
            }
            pub fn to_native_type_simple(&self) -> &str {
                match self {
                    AtomicType::String => "String",
                    AtomicType::Interger => "i32",
                    AtomicType::Byte => "i8",
                    AtomicType::Short => "i16",
                    AtomicType::Int => "i32",
                    AtomicType::Long => "i64",
                    AtomicType::Float => "f32",
                    AtomicType::Double => "f64",
                    AtomicType::Boolean => "bool",
                    AtomicType::Date => "String",
                    AtomicType::DateTime => "String",
                    AtomicType::DateTimeStamp => "u64",
                    AtomicType::Decimal => "f64",
                    AtomicType::AnyURI => "String",
                    AtomicType::Base64Binary => "String",
                    AtomicType::HexBinary => "String",
                    AtomicType::GDay => "String",
                    AtomicType::GMonth => "String",
                    AtomicType::GMonthDay => "String",
                    AtomicType::GYear => "String",
                    AtomicType::GYearMonth => "String",
                    AtomicType::Duration => "String",
                    AtomicType::Time => "String",
                    AtomicType::NormalizedString => "String",
                    AtomicType::Token => "String",
                    AtomicType::Language => "String",
                    AtomicType::Name => "String",
                    AtomicType::NCName => "String",
                    AtomicType::ENTITY => "String",
                    AtomicType::ID => "String",
                    AtomicType::IDREF => "String",
                    AtomicType::NMTOKEN => "String",
                    AtomicType::NonNegativeInteger => "u64",
                    AtomicType::PositiveInteger => "u64",
                    AtomicType::UnsignedLong => "u64",
                    AtomicType::UnsignedInt => "u32",
                    AtomicType::UnsignedShort => "u16",
                    AtomicType::UnsignedByte => "u8",
                    AtomicType::NonPositiveInteger => "i64",
                    AtomicType::NegativeInteger => "i64",
                    AtomicType::NOTATION => "String",
                    AtomicType::QName => "String",
                    AtomicType::DayTimeDuration => "String",
                    AtomicType::YearMonthDuration => "String",
                    AtomicType::None => "String",
                    AtomicType::Other => "String",
                }
            }
        }
    }
    pub mod common_type {
        use rs_xsd_parser_derive::string_based;
        pub struct QName {
            pub str: String,
        }
        impl QName {
            pub fn as_str(&self) -> &str {
                self.str.as_str()
            }
        }
        impl yaserde::YaDeserialize for QName {
            fn deserialize<R: std::io::Read>(
                reader: &mut yaserde::de::Deserializer<R>,
            ) -> Result<Self, String> {
                let mut ret = String::new();
                let mut err = None;
                loop {
                    let event = reader.peek()?;
                    match event {
                        xml::reader::XmlEvent::Characters(ref text_content) => {
                            ret.write_str(text_content).unwrap();
                        }
                        xml::reader::XmlEvent::EndElement { name: _ } => {
                            break;
                        }
                        _ => {
                            err = Some(
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("Unknown event"),
                                    );
                                    res
                                }),
                            );
                            break;
                        }
                    }
                    reader.next_event()?;
                }
                if let Some(err_str) = err {
                    Err(err_str)
                } else {
                    Ok(QName { str: ret })
                }
            }
        }
        impl yaserde::YaSerialize for QName {
            fn serialize<W: std::io::Write>(
                &self,
                writer: &mut yaserde::ser::Serializer<W>,
            ) -> Result<(), String> {
                writer
                    .write(yaserde::__xml::writer::XmlEvent::Characters(&self.str))
                    .map_err(|e| { e.to_string() })
            }
            fn serialize_attributes(
                &self,
                _attributes: Vec<xml::attribute::OwnedAttribute>,
                _namespace: xml::namespace::Namespace,
            ) -> Result<
                (Vec<xml::attribute::OwnedAttribute>, xml::namespace::Namespace),
                String,
            > {
                Ok((Vec::new(), xml::namespace::Namespace::empty()))
            }
        }
    }
    use std::fs;
    use std::io::Cursor;
    use std::str::FromStr;
    use xml::namespace::Namespace;
    use xml::reader::XmlEvent;
    use xml::EventReader;
    use yaserde::de::from_str;
    pub struct Xsd {
        pub name: String,
        pub namespace: Namespace,
        pub schema: schema::Schema,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Xsd {
        #[inline]
        fn clone(&self) -> Xsd {
            Xsd {
                name: ::core::clone::Clone::clone(&self.name),
                namespace: ::core::clone::Clone::clone(&self.namespace),
                schema: ::core::clone::Clone::clone(&self.schema),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Xsd {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Xsd",
                "name",
                &self.name,
                "namespace",
                &self.namespace,
                "schema",
                &&self.schema,
            )
        }
    }
    impl Xsd {
        pub fn read_namespace(content: &str) -> Namespace {
            let cursor = Cursor::new(content);
            let parser = EventReader::new(cursor);
            let mut xmlns_map: Option<Namespace> = None;
            for event in parser {
                match event {
                    Ok(XmlEvent::StartElement { attributes: _, name, namespace, .. }) => {
                        if name.local_name.ends_with("schema") {
                            xmlns_map = Some(namespace);
                            break;
                        }
                    }
                    Err(_) => {
                        break;
                    }
                    _ => {}
                }
            }
            xmlns_map.unwrap()
        }
        pub fn new(name: String, content: &str) -> Result<Self, String> {
            let schema: schema::Schema = from_str(content)?;
            Ok(Xsd {
                name,
                namespace: Xsd::read_namespace(content),
                schema,
            })
        }
        pub fn new_from_file(name: &str, source: &str) -> Result<Self, String> {
            let content = {
                let path = std::env::current_dir().unwrap();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("The current directory is {0}", path.display()),
                            lvl,
                            &(
                                "rs_xsd_parser::xsd",
                                "rs_xsd_parser::xsd",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                fs::read_to_string(source).map_err(|e| e.to_string())?
            };
            let content = if content.as_bytes()[0..3] == [0xef, 0xbb, 0xbf] {
                content[3..].to_owned()
            } else {
                content
            };
            Xsd::new(String::from_str(name).unwrap(), &content)
        }
    }
}
pub mod flatten {
    pub mod attribute {
        use std::{error::Error, fmt::Display};
        use crate::xsd::attribute::{
            Attribute, RefAttributeType, AttributeGroup, RefAttributeGroup,
        };
        use super::datamodel_map::XsdDataModel;
        pub struct FlattenError;
        #[automatically_derived]
        impl ::core::fmt::Debug for FlattenError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "FlattenError")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for FlattenError {
            #[inline]
            fn default() -> FlattenError {
                FlattenError {}
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FlattenError {}
        #[automatically_derived]
        impl ::core::clone::Clone for FlattenError {
            #[inline]
            fn clone(&self) -> FlattenError {
                *self
            }
        }
        pub struct FlattenAttribute<'a> {
            pub group: Option<&'a AttributeGroup>,
            pub attribute_list: Vec<&'a Attribute>,
        }
        impl Display for FlattenError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("flatten error"))
            }
        }
        impl RefAttributeType {
            pub fn flatten_attribute<'a>(
                &'a self,
                dm: &'a XsdDataModel,
            ) -> Result<Vec<FlattenAttribute<'a>>, FlattenError> {
                let mut ret = Vec::new();
                let mut attrs = Vec::new();
                for attr in &self.attributes {
                    attrs.push(attr);
                }
                ret.push(FlattenAttribute {
                    group: None,
                    attribute_list: attrs,
                });
                for rag in &self.attribute_groups {
                    if let Some(ag) = rag.deref(dm) {
                        let ag_fl = ag.flatten_attributes(dm);
                        if let Ok(res) = ag_fl {
                            for fa in res {
                                ret.push(fa);
                            }
                        } else {
                            return Err(FlattenError);
                        }
                    } else {
                        return Err(FlattenError);
                    }
                }
                Ok(ret)
            }
        }
        impl AttributeGroup {
            pub fn flatten_attributes<'a>(
                &'a self,
                dm: &'a XsdDataModel,
            ) -> Result<Vec<FlattenAttribute<'a>>, FlattenError> {
                let mut ret = Vec::new();
                let mut attrs = Vec::new();
                for attr in &self.attributes.attributes {
                    attrs.push(attr);
                }
                ret.push(FlattenAttribute {
                    group: Some(self),
                    attribute_list: attrs,
                });
                for rag in &self.attributes.attribute_groups {
                    if let Some(ag) = rag.deref(dm) {
                        let ag_fl = ag.flatten_attributes(dm);
                        if let Ok(res) = ag_fl {
                            for fa in res {
                                ret.push(fa);
                            }
                        } else {
                            return Err(FlattenError);
                        }
                    } else {
                        return Err(FlattenError);
                    }
                }
                Ok(ret)
            }
        }
        impl RefAttributeGroup {
            pub fn deref<'a>(
                &'a self,
                dm: &'a XsdDataModel,
            ) -> Option<&'a AttributeGroup> {
                if let Some(ref_name) = self.ref_v.as_ref() {
                    if let Some(r) = dm.attribute_group.get(ref_name) {
                        return Some(*r);
                    }
                }
                None
            }
        }
    }
    pub mod datamodel_map {
        use std::collections::BTreeMap;
        use crate::xsd::{
            attribute::{Attribute, AttributeGroup},
            element::{Element, TypeComponent},
            group::Group, types::{ComplexType, SimpleType},
            Xsd,
        };
        pub struct XsdDataModel<'a> {
            pub elements: BTreeMap<String, &'a Element>,
            pub simple_type: BTreeMap<String, &'a SimpleType>,
            pub complex_type: BTreeMap<String, &'a ComplexType>,
            pub attribute: BTreeMap<String, &'a Attribute>,
            pub attribute_group: BTreeMap<String, &'a AttributeGroup>,
            pub group: BTreeMap<String, &'a Group>,
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for XsdDataModel<'a> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "elements",
                    "simple_type",
                    "complex_type",
                    "attribute",
                    "attribute_group",
                    "group",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.elements,
                    &self.simple_type,
                    &self.complex_type,
                    &self.attribute,
                    &self.attribute_group,
                    &&self.group,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "XsdDataModel",
                    names,
                    values,
                )
            }
        }
        pub enum TypeFindResult<'a> {
            None,
            Simple(&'a SimpleType),
            Complex(&'a ComplexType),
        }
        impl<'a> XsdDataModel<'a> {
            pub fn build(xsd: &'a Xsd) -> Self {
                let mut elements = BTreeMap::new();
                let mut simple_type = BTreeMap::new();
                let mut complex_type = BTreeMap::new();
                let mut attribute = BTreeMap::new();
                let mut attribute_group = BTreeMap::new();
                let mut group = BTreeMap::new();
                let mut target_ns_prefix = "";
                if xsd.schema.target_namespace.is_some() {
                    let target_namespace = xsd.schema.target_namespace.as_ref().unwrap();
                    for (key, value) in xsd.namespace.iter() {
                        if value == target_namespace {
                            target_ns_prefix = key;
                        }
                    }
                }
                xsd.schema
                    .elements
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            elements
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                xsd.schema
                    .simple_type
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            simple_type
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                xsd.schema
                    .complex_type
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            complex_type
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                xsd.schema
                    .attribute
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            attribute
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                xsd.schema
                    .attribute_group
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            attribute_group
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                xsd.schema
                    .group
                    .iter()
                    .for_each(|e| {
                        if e.name.is_some() {
                            group
                                .insert(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0}:{1}",
                                                target_ns_prefix,
                                                e.name.as_ref().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                    e,
                                );
                        }
                    });
                Self {
                    elements,
                    simple_type,
                    complex_type,
                    attribute,
                    attribute_group,
                    group,
                }
            }
            pub fn find_type(&'a self, element: &'a Element) -> TypeFindResult<'a> {
                match &element.type_component {
                    TypeComponent::None => {
                        if let Some(name) = element.type_v.as_ref() {
                            if let Some(t) = self.simple_type.get(name) {
                                TypeFindResult::Simple(t)
                            } else if let Some(t) = self.complex_type.get(name) {
                                TypeFindResult::Complex(t)
                            } else {
                                TypeFindResult::None
                            }
                        } else {
                            TypeFindResult::None
                        }
                    }
                    TypeComponent::SimpleType(t) => TypeFindResult::Simple(t),
                    TypeComponent::ComplexType(t) => TypeFindResult::Complex(t),
                }
            }
        }
    }
    pub mod types {}
    use datamodel_map::XsdDataModel;
    use crate::xsd::{
        attribute::{Attribute, AttributeGroup, RefAttributeGroup, AttributeType},
        element::{Element, TypeComponent},
    };
    impl TypeComponent {
        pub fn flatten<'a>(&self, _xsd: &'a XsdDataModel) -> Self {
            match self {
                TypeComponent::None => self.clone(),
                TypeComponent::ComplexType(_ct) => self.clone(),
                TypeComponent::SimpleType(_st) => self.clone(),
            }
        }
    }
    impl Element {
        pub fn flatten<'a>(&self, xsd: &'a XsdDataModel) -> Self {
            let mut new = self.clone();
            if new.type_v.is_some() {
                let type_name = new.type_v.as_ref().unwrap();
                if let Some(ct) = xsd.complex_type.get(type_name) {
                    let t = (*ct).clone();
                    new.type_component = TypeComponent::ComplexType(t);
                } else if let Some(st) = xsd.simple_type.get(type_name) {
                    let t = (*st).clone();
                    new.type_component = TypeComponent::SimpleType(t);
                }
            }
            new.type_component.flatten(xsd);
            new
        }
    }
}
